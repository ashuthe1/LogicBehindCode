{
  "blogPosts": [
    {
      "id": "cp-roadmap-for-beginners-and-people-below-specialist",
      "metadata": {
        "permalink": "/cp-roadmap-for-beginners-and-people-below-specialist",
        "editUrl": "https://github.com/ashuthe1/blog/tree/main/blog/2023-04-17-cp-roadmap-for-beginners-and-people-below-specialist.mdx",
        "source": "@site/blog/2023-04-17-cp-roadmap-for-beginners-and-people-below-specialist.mdx",
        "title": "Cp Roadmap for beginners and People below Specialist",
        "description": "I come across folks who seek guidance for progressing in cp and most of them are pupils / newbies,",
        "date": "2023-04-17T00:00:00.000Z",
        "formattedDate": "April 17, 2023",
        "tags": [
          {
            "label": "CP",
            "permalink": "/tags/cp"
          },
          {
            "label": "Roadmap",
            "permalink": "/tags/roadmap"
          },
          {
            "label": "DSA",
            "permalink": "/tags/dsa"
          },
          {
            "label": "CodeChef",
            "permalink": "/tags/code-chef"
          },
          {
            "label": "CodeForces",
            "permalink": "/tags/code-forces"
          }
        ],
        "readingTime": 6.075,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Ashutosh Gautam",
            "title": "4 ðŸŒŸ CodeChefðŸ”¸Specialist @CodeForces ðŸ”¸Problem Setter at iMochaWorks",
            "url": "https://www.linkedin.com/in/ashuthe1/",
            "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
            "key": "ashuthe1"
          }
        ],
        "frontMatter": {
          "slug": "cp-roadmap-for-beginners-and-people-below-specialist",
          "title": "Cp Roadmap for beginners and People below Specialist",
          "authors": [
            "ashuthe1"
          ],
          "tags": [
            "CP",
            "Roadmap",
            "DSA",
            "CodeChef",
            "CodeForces"
          ]
        },
        "nextItem": {
          "title": "232. Implement Queue using Stacks",
          "permalink": "/leetcode/implement-queue-using-stacks"
        }
      },
      "content": "I come across folks who seek guidance for progressing in cp and most of them are pupils / newbies, \nbecause when you reach a Specialist you yourself know what has to be done to progress further . So for those here is some advice. \n\nSo let's start with Beginners or People with rating 800 - 1200. <br/>\nIf your graph looks something like below profile , you are at level 1 , your first goal should be reaching <br/> specialist -> 1400 rating . \n\n<!--truncate-->\n\n![image](https://user-images.githubusercontent.com/86846633/232587990-4b17bdf4-8eef-40a0-9fe2-88772605d39f.png)\n\nTopics needed to attain level 2 (>=1400) in order of their importance.\n\n0) stl in c++ , Collections in Java or equivalent . <br/>\n1) Basic maths , basic logic  <br/>\n2) Searching - Sorting , greedy , two pointers ,sliding window  <br/>\n3) Implementation , stl based  <br/>\n4) Binary search ( very important and a saviour) <br/> \n5) Number theory  <br/>\n6) Basic bit manipulation and basic combinatorics. (very basic)\n\n## Practice strategy \nTwo types of practice are needed :-  <br/>\n1) to build critical thinking / problem solving / application of concepts known.  <br/>\n2) to learn new concepts, tricks and standard problems.  <br/>\n\nFor the first kind of practice you have to solve 40 each in the rating range 800-1400. You can skip a level if you are way too comfortable with it , but don't do more than 50 of any level and waste your time , most beginners do 100-150 800â€™s which are completely wasted as in the above profile, the person has done 100 800â€™s .\nSo do 40 each 800->900->1000->1100->1200->1300->1400.\nNow at this point you would be able to do A,B and C sometimes.\nNow do 10 more of each if you want .\nNow if you do this you will reach near 1400 . \n\n## Learning strategy\nYou can learn on the fly by just reading editorials and solutions , but it would be more helpful if you spare some time for learning new things.\nFor the topics listed above just search on youtube or google about what are those algos now for doing some standard problems. Resource is Cses Problemset - those are educative and standard problems.\nCompetitive programming handbook - very soothing book .\nLuvâ€™s youtube channel has a competitive programming playlist\nWhich is also a nice resource to learn things from beginners' pov . \nYou can actually follow any thing you wish just search on google / yt try reading/ watching if you don't get ,-> switch , after two three tries , you will find something which works for you .\n\nBottomline - practice consistently and 40/50 of each rating till 1400 and learn some standard algos , tricks .\n\n\n\n\n\n\n\n\nFrom level 2 (1400) to level 3 (1500-Expert) .\n\nTopics : \nStrong implementation  , speed , accuracy and brute force.\nBinary Search(very important ),\nNumber Theory , \nBit manipulation and Combinatorics ( basic - intermediate)\nTrees / graph -> basic ( questions <=1600/1700 rated)\nDynamic Programming ( 1600-1700 ) , standard problems.\n\nPractice strategy\n1)  For first kind of practice\nnow you need to practise 40 each in 1500 - 1600\nThen 10 each of both .\nNow if you have 50 of each till 1600 begin with 1700 , 1800 \nStrategy remains the same 40 each then after 10 more for each .\n2)  For second kind - Learning strategy \nLearn binary search on answer and everything related to binary search \nDo some good problems on bit manipulation and combinatorics as you encounter them.\nStart learning dp and trees side by side or one after from youtube or wherever you wish ( I started trees from codencode and dp from Aditya Verma) .\nCan refer Cses for standard problems. \n\nBottomline:- If you do this you will reach or have potential to reach expert(>1600) .\n\n\n\n3) For people being specialist and want to reach Expert \n\nYou have to do 40-50 each till 1800 .\n When you complete 1800 then you might reach Expert soon , \nI take it like this - you should solve <=x+200 in problems set to reach a rating x in contests .\nTopics to be covered - Trees ,Graphs, Dp , Segment trees/Range query data structures.\nLearn various useful graphs algos like mst, toposort etc , you should be doing plenty of problems on dp , you should learn segment trees and solve questions on it.\nSo all in all you have to master these topics and come to intermediate or above intermediate level .\nResources- Cp algorithms , Competitive programming handbook,\nAnd tbh any good tutorial , web or video based which you like ,     doesn't matter much .\n\n\n\n## Necessary points to keep in mind  :\n\n1) Participate in every contest , don't care about ratings till you reach an expert. Learnings in one contest = learnings for one week in practice .\n\n2) Always upsolve the problem you couldn't do (<=C in cf div2 rounds) and watch others' solutions who are better rated / your idols -how , why they did that problem in that way ,(lol just stalk their solutions ).\n\n3) In a month if you do 100 problems it's great , you should tap on your shoulder. That costs like 3 problems a day, very much doable if consistent. \n\n4) If you feel uncomfortable with the new rating donâ€™t back out, it's fine . \nWhen I moved to a new rating I did the first 20 mostly by reading editorials, \ntaking hints etc . You can do the same but just understand the intuition behind it.\nAlso you will come across some problem where you wonâ€™t understand anything even after reading \neditorial and trying your way out . In such a situation , leave that problem for the future or ignore it for  sometime but donâ€™t waste your day on that one problem .\n5) Make a habit of learning some algo or doing some standard tasks like cses too.\n\n6) Be consistent , be confident , and perform in contests and if couldnt analyse your mistakes.\n\n7) One more golden advice in each question is to try to extract some conclusions/ some facts / some standard knowledge which you can use in other problems too. For example median is the point which has the least sum of difference from n points . Anything, the bottomline is that from each problem you should try to extract some takeaways which you can use in other problems too. \n\n8) Uplift yourself no matter what , even if you are on bottom of rank list just know that , you are still the best , donâ€™t be too harsh on yourself because-there is whole world against  you and at the end of the day It has to be you on your side ,  only you are there to pamper yourself so be easy on yourself , just learn from your mistakes and remember everyday is a new day .\n\n9) Save the algorithms or implementation in files or snippets so that you can revisit , for example I have many files named as , graph_algorithms, dp , utility functions , string algos, range based data structures etc. So when I forget something I revisit that also I can use codes in contests.\n\n## Who am I ? \nhttps://www.codechef.com/users/ashuthe1x ."
    },
    {
      "id": "leetcode/implement-queue-using-stacks",
      "metadata": {
        "permalink": "/leetcode/implement-queue-using-stacks",
        "editUrl": "https://github.com/ashuthe1/blog/tree/main/blog/leetcode-daily/2022-12-16-implement-queue-using-stacks.mdx",
        "source": "@site/blog/leetcode-daily/2022-12-16-implement-queue-using-stacks.mdx",
        "title": "232. Implement Queue using Stacks",
        "description": "Problem Statement",
        "date": "2022-12-16T00:00:00.000Z",
        "formattedDate": "December 16, 2022",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/tags/leet-code"
          },
          {
            "label": "Leetcode Daily",
            "permalink": "/tags/leetcode-daily"
          },
          {
            "label": "DSA",
            "permalink": "/tags/dsa"
          },
          {
            "label": "Stack",
            "permalink": "/tags/stack"
          },
          {
            "label": "Queue",
            "permalink": "/tags/queue"
          }
        ],
        "readingTime": 3.265,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Ashutosh Gautam",
            "title": "4 ðŸŒŸ CodeChefðŸ”¸Specialist @CodeForces ðŸ”¸Problem Setter at iMochaWorks",
            "url": "https://www.linkedin.com/in/ashuthe1/",
            "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
            "key": "ashuthe1"
          }
        ],
        "frontMatter": {
          "slug": "leetcode/implement-queue-using-stacks",
          "title": "232. Implement Queue using Stacks",
          "authors": "ashuthe1",
          "tags": [
            "LeetCode",
            "Leetcode Daily",
            "DSA",
            "Stack",
            "Queue"
          ]
        },
        "prevItem": {
          "title": "Cp Roadmap for beginners and People below Specialist",
          "permalink": "/cp-roadmap-for-beginners-and-people-below-specialist"
        },
        "nextItem": {
          "title": "Longest Common Subsequence, LeetCode",
          "permalink": "/leetcode/longest-common-subsequence"
        }
      },
      "content": "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Problem Statement\n\nImplement a first in first out (FIFO) queue using only two stacks.\nThe implemented queue should support all the functions of a normal\nqueue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n`void push(int x)` Pushes element x to the back of the queue.\n`int pop()` Removes the element from the front of the queue and returns it.\n`int peek()` Returns the element at the front of the queue.\n`boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n<!--truncate-->\n\n**Notes:**\n\n- You must use only standard operations of a stack, which means only `push to top`,\n`peek/pop from top`, `size`, and `is empty` operations are valid.\n- Depending on your language, the stack may not be supported natively. You may\nsimulate a stack using a list or deque (double-ended queue) as long as you use\nonly a stack's standard operations.\n\nExample 1:\n```text\nInput:\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput:\n[null, null, null, 1, 1, false]\n\nExplanation:\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\nConstraints:\n- `1 <= x <= 9`\n- At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.\n- All the calls to `pop` and `peek` are valid.\n\n## Follow Up\nCan you implement the queue such that each operation is [amortized](https://en.wikipedia.org/wiki/Amortized_analysis)\n`O(1)` time complexity? In other words, performing `n` operations will take\noverall `O(n)` time even if one of those operations may take longer.\n\n## Explanation\n\nProperties of Queue:\n```mermaid\nflowchart LR;\n\nqueue[Queue Data Structure];\npush((Push));\npeek((Peek));\npop((Pop));\nfront[Front];\nback[Back];\n\npop --- front --- queue --- back --- push;\npeek --- front;\n```\n\nProperties of Stack:\n```mermaid\nflowchart LR;\n\nstack[Stack Data Structure];\npush((Push));\npeek((Peek));\npop((Pop));\nfront[Front];\nback[Back];\n\nfront --- stack --- back --- push;\nback --- pop;\nback --- peek;\n```\n\nInorder to create queue using stack, we can use combination of 2 stacks (say `stack1`, `stack2`);\n\n### Queue: Push\n- push new element to `stack1`\n- oldest element pushed will be in the bottom of stack\n- newest element pushed will be on the top of stack\n\n### Queue: Peek\n- IF `stack2` is empty then oldest element will be at the\nbottom of `stack1` else oldest element will be on top of `stack2`\n```text\nIF stack2 is empty\n    WHILE stack1 is not empty\n        pop element from stack1\n        push element into stack2\n```\n- Now, oldest element will always be on the top of `stack2`\n\n### Queue: Pop\n- same as finding the peek, then just pop peek element from `stack2`.\n- after, pop operation on `stack2`, 2nd oldest will again come on top of `stack2`.\n\n## Solution\n\n<Tabs>\n\n<TabItem value=\"cpp\" label=\"C++ Two User Stack\">\n\n```cpp title='C++ Solution using Two User Defined Stack'\nclass MyQueue {\nprivate:\n    stack<int> s1, s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty()) {\n            while(!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int ans = s2.top();\n        s2.pop();\n        return ans;\n    }\n    \n    int peek() {\n        if(s2.empty()) {\n            while(!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.size() + s2.size() == 0;\n    }\n};\n\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\nTime Complexity:\n- Push: O(1)\n- Pop: O(N), amortized: O(1)\n- Peek: O(N), amortized: O(1)\n\nSpace Complexity: O(N)\n\n</TabItem>\n\n</Tabs>\n\n\n## Related Problems\n- [Implement Stack using Queues - GeeksforGeeks](https://www.geeksforgeeks.org/implement-stack-using-queue/)\n- [225. Implement Stack using Queues - LeetCode](https://leetcode.com/problems/implement-stack-using-queues/)\n\n## References\n- [Queue using Stacks - GeeksforGeeks](https://www.geeksforgeeks.org/queue-using-stacks/)\n\n## Links\n- [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\n- [LeetCode Discussion Post - Suraj Jha](https://leetcode.com/problems/implement-queue-using-stacks/solutions/2918885/c-solution-using-two-user-defined-stack-time-o-1-space-o-n/)"
    },
    {
      "id": "leetcode/longest-common-subsequence",
      "metadata": {
        "permalink": "/leetcode/longest-common-subsequence",
        "editUrl": "https://github.com/ashuthe1/blog/tree/main/blog/leetcode-daily/2022-12-15-longest-common-subsequence.mdx",
        "source": "@site/blog/leetcode-daily/2022-12-15-longest-common-subsequence.mdx",
        "title": "Longest Common Subsequence, LeetCode",
        "description": "Problem Statement",
        "date": "2022-12-15T00:00:00.000Z",
        "formattedDate": "December 15, 2022",
        "tags": [
          {
            "label": "LeetCode",
            "permalink": "/tags/leet-code"
          },
          {
            "label": "Leetcode Daily",
            "permalink": "/tags/leetcode-daily"
          },
          {
            "label": "DSA",
            "permalink": "/tags/dsa"
          },
          {
            "label": "Dynamic Programming",
            "permalink": "/tags/dynamic-programming"
          },
          {
            "label": "String",
            "permalink": "/tags/string"
          }
        ],
        "readingTime": 3.105,
        "hasTruncateMarker": true,
        "authors": [
          {
            "name": "Ashutosh Gautam",
            "title": "4 ðŸŒŸ CodeChefðŸ”¸Specialist @CodeForces ðŸ”¸Problem Setter at iMochaWorks",
            "url": "https://www.linkedin.com/in/ashuthe1/",
            "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
            "key": "ashuthe1"
          }
        ],
        "frontMatter": {
          "slug": "leetcode/longest-common-subsequence",
          "title": "Longest Common Subsequence, LeetCode",
          "authors": "ashuthe1",
          "tags": [
            "LeetCode",
            "Leetcode Daily",
            "DSA",
            "Dynamic Programming",
            "String"
          ]
        },
        "prevItem": {
          "title": "232. Implement Queue using Stacks",
          "permalink": "/leetcode/implement-queue-using-stacks"
        }
      },
      "content": "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Problem Statement\n\nGiven two strings `text1` and `text2`, return the length of their *longest common subsequence*. If there is no common subsequence, return `0`.\n\nA *subsequence* of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n- For example, `\"ace\"` is a subsequence of `\"abcde\"`.\n\nA *common subsequence* of two strings is a subsequence that is common to both strings. \n\n<!--truncate-->\n\nExample 1:\n```text\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\nExample 2:\n```text\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\nExample 3:\n```text\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\nConstraints:\n- `1 <= text1.length, text2.length <= 1000`\n- `text1` and `text2` consist of only lowercase English characters.\n\n## Explanation\n\nLet `i1` and `i2` be two pointer pointing at `current` index in string `s1` and `s2` respectively.\n\nlet `dp(i1, i2, s1, s2)` denotes the length of longest common subsequence in string `s1[i1...n1]` and `s2[i2...n2]`.\n\nIf _i1 == n1_, implies s1[i1....n1] is empty.\n\n**Base Case:** longest common subsequence of any string with empty string is 0.\nTherefore is any of _i1 == n1_ or _i2 == n2_ return `0`.\n\nNow, for any `i1` and `i2` there are 2 possibilities.\n\n```mermaid\ngraph TD;\n    root[\"(i1, i2)\"];\n    eq[\"s1[i1] == s2[i2]\"];\n    nq[\"s1[i1] != s2[i2]\"];\n\n    root --> eq -- Pick --> Pick[\"Consider Current Characters in Subsequence\"] --Recursive Call--> next[\"(i1+1, i2+1)\"];\n    eq -- Skip --> Skip[\"Skip Current Characters either from s1 or s2\"];\n\n    root --> nq -- Skip --> Skip;\n\n    Skip --Recursive Call--> next_i1[\"(i1+1, i2)\"];\n    Skip --Recursive Call--> next_i2[\"(i1, i2+1)\"];\n```\n\n## Solution\n\n<Tabs>\n\n<TabItem value=\"cpp1\" label=\"C++ Recursive\">\n\n```cpp title='CPP: Recursive Brute Force Solution [Time Limit Exceeded]'\nclass Solution {\nprivate:\n    int dp(int i1, int i2, string &s1, string &s2) {\n        int n1 = s1.size();\n        int n2 = s2.size();\n\n        // Base Case\n        if(i1 == n1 || i2 == n2) return 0;\n\n        if(s1[i1] == s2[i2]) {\n            return max({\n                dp(i1+1, i2+1, s1, s2) + 1,\n                dp(i1, i2+1, s1, s2),\n                dp(i1+1, i2, s1, s2),\n            });\n        }\n        else {\n            return max({\n                dp(i1, i2+1, s1, s2),\n                dp(i1+1, i2, s1, s2),\n            });\n        }\n    }\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        return dp(0, 0, text1, text2);\n    }\n};\n```\n\nm               |n                  | Time Complexity  | Space Complexity\n----------------|-------------------|------------------|-----------------\nsize of string 1|size of string 2   | O(max(m,n)\\*m\\*n)| O(max(m,n))\n\n</TabItem>\n\n<TabItem value=\"cpp2\" label=\"C++ Recursive DP\">\n\n```cpp title='CPP: Recursive + Memoization [Accepted]'\nclass Solution {\nprivate:\n    int dp(int i1, int i2, string &s1, string &s2, vector<vector<int>> &cache) {\n        int n1 = s1.size();\n        int n2 = s2.size();\n\n        // Base Case\n        if(i1 == n1 || i2 == n2) return 0;\n\n        if(cache[i1][i2] != -1) return cache[i1][i2];\n\n        if(s1[i1] == s2[i2]) {\n            return cache[i1][i2] = max({\n                dp(i1+1, i2+1, s1, s2, cache) + 1,\n                dp(i1, i2+1, s1, s2, cache),\n                dp(i1+1, i2, s1, s2, cache),\n            });\n        }\n        else {\n            return cache[i1][i2] = max({\n                dp(i1, i2+1, s1, s2, cache),\n                dp(i1+1, i2, s1, s2, cache),\n            });\n        }\n    }\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector<vector<int>> cache(text1.size(), vector<int>(text2.size(), -1));\n        return dp(0, 0, text1, text2, cache);\n    }\n};\n```\n\n\nm               |n                  | Time Complexity  | Space Complexity\n----------------|-------------------|------------------|-----------------\nsize of string 1|size of string 2   | O(m*n)           | O(m*n)\n\n</TabItem>\n\n</Tabs>\n\n\n## Related Problems\n- [Longest Common Substring](https://leetcode.com/discuss/interview-question/1273766/longest-common-substring)\n- [1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/)\n- [1062. Longest Repeating Substring](https://leetcode.com/problems/longest-repeating-substring/)\n- [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)\n\n## References\n- [Longest common subsequence Recursive - YouTube, Aditya Verma](https://youtu.be/4Urd0a0BNng)\n- [Longest common subsequence Tabular - YouTube, Tushar Roy](https://youtu.be/NnD96abizww)"
    }
  ]
}