{
  "docusaurus-plugin-content-docs": {
    "default": {
      "loadedVersions": [
        {
          "versionName": "current",
          "label": "Next",
          "banner": null,
          "badge": false,
          "noIndex": false,
          "className": "docs-version-current",
          "path": "/",
          "tagsPath": "/tags",
          "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs",
          "editUrlLocalized": "https://github.com/ashuthe1/LogicBehindCode/tree/main/i18n/en/docusaurus-plugin-content-docs/current",
          "isLast": true,
          "routePriority": -1,
          "sidebarFilePath": "/home/ashuthe1/projects/personal/LogicBehindCode Blogs/sidebars.js",
          "contentPath": "/home/ashuthe1/projects/personal/LogicBehindCode Blogs/docs",
          "contentPathLocalized": "/home/ashuthe1/projects/personal/LogicBehindCode Blogs/i18n/en/docusaurus-plugin-content-docs/current",
          "docs": [
            {
              "unversionedId": "algorithms/intro",
              "id": "algorithms/intro",
              "title": "Introduction to Algorithms",
              "description": "The word Algorithm means ‚ÄùA set of finite rules or instructions to be followed in calculations or other problem-solving operations‚Äù Or ‚ÄùA procedure for solving a mathematical problem in a finite number of steps that frequently involves recursive operations‚Äù.",
              "source": "@site/docs/algorithms/01-intro.md",
              "sourceDirName": "algorithms",
              "slug": "/algorithms/intro",
              "permalink": "/algorithms/intro",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/algorithms/01-intro.md",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "sidebar_position": 1,
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "next": {
                "title": "Kadane's Algorithm",
                "permalink": "/algorithms/kadanes-algorithm/"
              }
            },
            {
              "unversionedId": "algorithms/kadanes-algorithm/flip-bits",
              "id": "algorithms/kadanes-algorithm/flip-bits",
              "title": "Flip Bits",
              "description": "Problem Statement",
              "source": "@site/docs/algorithms/02-kadanes-algorithm/flip-bits.mdx",
              "sourceDirName": "algorithms/02-kadanes-algorithm",
              "slug": "/algorithms/kadanes-algorithm/flip-bits",
              "permalink": "/algorithms/kadanes-algorithm/flip-bits",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/algorithms/02-kadanes-algorithm/flip-bits.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Flip Bits",
                "displayed_sidebar": "algorithms",
                "keywords": [
                  "Kadane's Algorithms",
                  "Flip Bits",
                  "Dynamic Programming",
                  "Subarray",
                  "Maximize number of 1s by flipping a subarray"
                ]
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Kadane's Algorithm",
                "permalink": "/algorithms/kadanes-algorithm/"
              },
              "next": {
                "title": "Maximum Subarray Sum",
                "permalink": "/algorithms/kadanes-algorithm/maximum-subarray-sum"
              }
            },
            {
              "unversionedId": "algorithms/kadanes-algorithm/index",
              "id": "algorithms/kadanes-algorithm/index",
              "title": "Kadane's Algorithm",
              "description": "Kadane's algorithm is an algorithm for finding the maximum sum of a",
              "source": "@site/docs/algorithms/02-kadanes-algorithm/index.mdx",
              "sourceDirName": "algorithms/02-kadanes-algorithm",
              "slug": "/algorithms/kadanes-algorithm/",
              "permalink": "/algorithms/kadanes-algorithm/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/algorithms/02-kadanes-algorithm/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Introduction to Algorithms",
                "permalink": "/algorithms/intro"
              },
              "next": {
                "title": "Flip Bits",
                "permalink": "/algorithms/kadanes-algorithm/flip-bits"
              }
            },
            {
              "unversionedId": "algorithms/kadanes-algorithm/maximum-subarray-sum",
              "id": "algorithms/kadanes-algorithm/maximum-subarray-sum",
              "title": "Maximum Subarray Sum",
              "description": "Solution",
              "source": "@site/docs/algorithms/02-kadanes-algorithm/maximum-subarray-sum.mdx",
              "sourceDirName": "algorithms/02-kadanes-algorithm",
              "slug": "/algorithms/kadanes-algorithm/maximum-subarray-sum",
              "permalink": "/algorithms/kadanes-algorithm/maximum-subarray-sum",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/algorithms/02-kadanes-algorithm/maximum-subarray-sum.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Maximum Subarray Sum",
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Flip Bits",
                "permalink": "/algorithms/kadanes-algorithm/flip-bits"
              },
              "next": {
                "title": "Monotonic Stack",
                "permalink": "/algorithms/monotonic-stack/"
              }
            },
            {
              "unversionedId": "algorithms/monotonic-stack/index",
              "id": "algorithms/monotonic-stack/index",
              "title": "Monotonic Stack",
              "description": "Problems",
              "source": "@site/docs/algorithms/03-monotonic-stack/index.mdx",
              "sourceDirName": "algorithms/03-monotonic-stack",
              "slug": "/algorithms/monotonic-stack/",
              "permalink": "/algorithms/monotonic-stack/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/algorithms/03-monotonic-stack/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Maximum Subarray Sum",
                "permalink": "/algorithms/kadanes-algorithm/maximum-subarray-sum"
              },
              "next": {
                "title": "String Algorithms",
                "permalink": "/algorithms/string-algorithms"
              }
            },
            {
              "unversionedId": "algorithms/string-algorithms",
              "id": "algorithms/string-algorithms",
              "title": "String Algorithms",
              "description": "Here is a list of some common string algorithms:",
              "source": "@site/docs/algorithms/04-string-algorithms.mdx",
              "sourceDirName": "algorithms",
              "slug": "/algorithms/string-algorithms",
              "permalink": "/algorithms/string-algorithms",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/algorithms/04-string-algorithms.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 4,
              "frontMatter": {
                "title": "String Algorithms",
                "displayed_sidebar": "algorithms",
                "keywords": [
                  "Algorithms on String",
                  "String"
                ]
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Monotonic Stack",
                "permalink": "/algorithms/monotonic-stack/"
              }
            },
            {
              "unversionedId": "data-structures/graph/bipartite-graph/index",
              "id": "data-structures/graph/bipartite-graph/index",
              "title": "Bipartite Graph",
              "description": "Solved Examples",
              "source": "@site/docs/data-structures/graph/bipartite-graph/index.mdx",
              "sourceDirName": "data-structures/graph/bipartite-graph",
              "slug": "/data-structures/graph/bipartite-graph/",
              "permalink": "/data-structures/graph/bipartite-graph/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/graph/bipartite-graph/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Bipartite Graph",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Bipartite",
                  "Graph"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Connected Components",
                "permalink": "/data-structures/graph/connected-components"
              },
              "next": {
                "title": "Possible Bipartition",
                "permalink": "/data-structures/graph/bipartite-graph/possible_bipartition"
              }
            },
            {
              "unversionedId": "data-structures/graph/bipartite-graph/possible_bipartition",
              "id": "data-structures/graph/bipartite-graph/possible_bipartition",
              "title": "Possible Bipartition",
              "description": "Problem Statement",
              "source": "@site/docs/data-structures/graph/bipartite-graph/01_possible_bipartition.mdx",
              "sourceDirName": "data-structures/graph/bipartite-graph",
              "slug": "/data-structures/graph/bipartite-graph/possible_bipartition",
              "permalink": "/data-structures/graph/bipartite-graph/possible_bipartition",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/graph/bipartite-graph/01_possible_bipartition.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "title": "Possible Bipartition",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Possible Bipartition",
                  "Bipartite",
                  "Graph",
                  "DSA"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Bipartite Graph",
                "permalink": "/data-structures/graph/bipartite-graph/"
              },
              "next": {
                "title": "Tree",
                "permalink": "/data-structures/tree/"
              }
            },
            {
              "unversionedId": "data-structures/graph/connected-components",
              "id": "data-structures/graph/connected-components",
              "title": "Connected Components",
              "description": "Practice Problems",
              "source": "@site/docs/data-structures/graph/01_connected-components.mdx",
              "sourceDirName": "data-structures/graph",
              "slug": "/data-structures/graph/connected-components",
              "permalink": "/data-structures/graph/connected-components",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/graph/01_connected-components.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "title": "Connected Components",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Connected Components",
                  "Graph"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Graph",
                "permalink": "/data-structures/graph/"
              },
              "next": {
                "title": "Bipartite Graph",
                "permalink": "/data-structures/graph/bipartite-graph/"
              }
            },
            {
              "unversionedId": "data-structures/graph/index",
              "id": "data-structures/graph/index",
              "title": "Graph",
              "description": "Here are some important topics related to graphs that are commonly covered in technical interviews:",
              "source": "@site/docs/data-structures/graph/index.mdx",
              "sourceDirName": "data-structures/graph",
              "slug": "/data-structures/graph/",
              "permalink": "/data-structures/graph/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/graph/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Graph",
                "displayed_sidebar": "dataStructures"
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Introduction to Data Structures",
                "permalink": "/data-structures/intro"
              },
              "next": {
                "title": "Connected Components",
                "permalink": "/data-structures/graph/connected-components"
              }
            },
            {
              "unversionedId": "data-structures/intro",
              "id": "data-structures/intro",
              "title": "Introduction to Data Structures",
              "description": "A data structure is a storage that is used to store and organize data. It is a way of arranging data on a computer so that it can be accessed and updated efficiently.",
              "source": "@site/docs/data-structures/01_intro.mdx",
              "sourceDirName": "data-structures",
              "slug": "/data-structures/intro",
              "permalink": "/data-structures/intro",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/01_intro.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "sidebar_position": 1,
                "displayed_sidebar": "dataStructures"
              },
              "sidebar": "dataStructures",
              "next": {
                "title": "Graph",
                "permalink": "/data-structures/graph/"
              }
            },
            {
              "unversionedId": "data-structures/tree/dfs",
              "id": "data-structures/tree/dfs",
              "title": "DFS traversal in Tree",
              "description": "Algorithm",
              "source": "@site/docs/data-structures/tree/01-dfs.mdx",
              "sourceDirName": "data-structures/tree",
              "slug": "/data-structures/tree/dfs",
              "permalink": "/data-structures/tree/dfs",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/tree/01-dfs.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "title": "DFS traversal in Tree",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "DFS",
                  "Depth first search",
                  "Tree",
                  "Data Structure",
                  "Algorithm"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Tree",
                "permalink": "/data-structures/tree/"
              },
              "next": {
                "title": "Root Shifting",
                "permalink": "/data-structures/tree/root-shifting"
              }
            },
            {
              "unversionedId": "data-structures/tree/index",
              "id": "data-structures/tree/index",
              "title": "Tree",
              "description": "Here are some important topics related to trees that are commonly covered in technical interviews:",
              "source": "@site/docs/data-structures/tree/index.mdx",
              "sourceDirName": "data-structures/tree",
              "slug": "/data-structures/tree/",
              "permalink": "/data-structures/tree/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/tree/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Tree",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Tree",
                  "DSA",
                  "Algorithms"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Possible Bipartition",
                "permalink": "/data-structures/graph/bipartite-graph/possible_bipartition"
              },
              "next": {
                "title": "DFS traversal in Tree",
                "permalink": "/data-structures/tree/dfs"
              }
            },
            {
              "unversionedId": "data-structures/tree/root-shifting",
              "id": "data-structures/tree/root-shifting",
              "title": "Root Shifting",
              "description": "Practice Problems",
              "source": "@site/docs/data-structures/tree/99-root-shifting.mdx",
              "sourceDirName": "data-structures/tree",
              "slug": "/data-structures/tree/root-shifting",
              "permalink": "/data-structures/tree/root-shifting",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/data-structures/tree/99-root-shifting.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 99,
              "frontMatter": {
                "title": "Root Shifting",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Root Shifting",
                  "Tree",
                  "Data Structure",
                  "Algorithm"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "DFS traversal in Tree",
                "permalink": "/data-structures/tree/dfs"
              }
            },
            {
              "unversionedId": "standard-problems/Blind75",
              "id": "standard-problems/Blind75",
              "title": "Blind75",
              "description": "Array",
              "source": "@site/docs/standard-problems/01-Blind75.md",
              "sourceDirName": "standard-problems",
              "slug": "/standard-problems/Blind75",
              "permalink": "/standard-problems/Blind75",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/standard-problems/01-Blind75.md",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {},
              "sidebar": "sidebar",
              "previous": {
                "title": "Standard Problems",
                "permalink": "/category/standard-problems"
              },
              "next": {
                "title": "CSES Problem Set",
                "permalink": "/standard-problems/CSES ProblemSet"
              }
            },
            {
              "unversionedId": "standard-problems/CSES ProblemSet",
              "id": "standard-problems/CSES ProblemSet",
              "title": "CSES Problem Set",
              "description": "This document contains a numbered list of all the problems from the",
              "source": "@site/docs/standard-problems/02-CSES ProblemSet.md",
              "sourceDirName": "standard-problems",
              "slug": "/standard-problems/CSES ProblemSet",
              "permalink": "/standard-problems/CSES ProblemSet",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/standard-problems/02-CSES ProblemSet.md",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 2,
              "frontMatter": {},
              "sidebar": "sidebar",
              "previous": {
                "title": "Blind75",
                "permalink": "/standard-problems/Blind75"
              },
              "next": {
                "title": "Web Development",
                "permalink": "/category/web-development"
              }
            },
            {
              "unversionedId": "web-development/JavaScript/javascript-scopes",
              "id": "web-development/JavaScript/javascript-scopes",
              "title": "JavaScript Scopes",
              "description": "If you have written even a single line of JavaScript code then you have used one of the four scopes of JavaScript without even realizing it.",
              "source": "@site/docs/web-development/JavaScript/02_javascript-scopes.mdx",
              "sourceDirName": "web-development/JavaScript",
              "slug": "/web-development/JavaScript/javascript-scopes",
              "permalink": "/web-development/JavaScript/javascript-scopes",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/web-development/JavaScript/02_javascript-scopes.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 2,
              "frontMatter": {
                "title": "JavaScript Scopes",
                "displayed_sidebar": "webDevelopment",
                "authors": "Ashutosh",
                "keywords": [
                  "JavaScript"
                ]
              },
              "sidebar": "webDevelopment",
              "previous": {
                "title": "JavaScript Promises",
                "permalink": "/web-development/JavaScript/promise"
              }
            },
            {
              "unversionedId": "web-development/JavaScript/promise",
              "id": "web-development/JavaScript/promise",
              "title": "JavaScript Promises",
              "description": "Promises in JavaScript look confusing at first but I promise you by the end of this article",
              "source": "@site/docs/web-development/JavaScript/01_promise.mdx",
              "sourceDirName": "web-development/JavaScript",
              "slug": "/web-development/JavaScript/promise",
              "permalink": "/web-development/JavaScript/promise",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/web-development/JavaScript/01_promise.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "title": "JavaScript Promises",
                "displayed_sidebar": "webDevelopment",
                "authors": "Ashutosh",
                "keywords": [
                  "JavaScript",
                  "Promises"
                ]
              },
              "sidebar": "webDevelopment",
              "previous": {
                "title": "MongoDB Tutorial",
                "permalink": "/web-development/mongodb-tutorial"
              },
              "next": {
                "title": "JavaScript Scopes",
                "permalink": "/web-development/JavaScript/javascript-scopes"
              }
            },
            {
              "unversionedId": "web-development/mongodb",
              "id": "web-development/mongodb",
              "title": "MongoDB Tutorial",
              "description": "MongoDB is a NoSQL document based database. Essentially, all the data in MongoDB is stored in JSON documents that are sorted into a variety of collections based on the type of data. It is one of the most popular NoSQL database options due to its relative ease of use and power. In this article I will be covering a ton of concepts and functions in MongoDB which touch on all the important aspects of MongoDB.",
              "source": "@site/docs/web-development/01-mongodb.md",
              "sourceDirName": "web-development",
              "slug": "/web-development/mongodb-tutorial",
              "permalink": "/web-development/mongodb-tutorial",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/docs/web-development/01-mongodb.md",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "slug": "mongodb-tutorial",
                "title": "MongoDB Tutorial",
                "authors": "Ashutosh"
              },
              "sidebar": "sidebar",
              "previous": {
                "title": "Web Development",
                "permalink": "/category/web-development"
              },
              "next": {
                "title": "JavaScript Promises",
                "permalink": "/web-development/JavaScript/promise"
              }
            }
          ],
          "drafts": [],
          "sidebars": {
            "dataStructures": [
              {
                "type": "doc",
                "id": "data-structures/intro"
              },
              {
                "type": "category",
                "label": "Graph",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "data-structures/graph/connected-components"
                  },
                  {
                    "type": "category",
                    "label": "Bipartite Graph",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "data-structures/graph/bipartite-graph/possible_bipartition"
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "data-structures/graph/bipartite-graph/index"
                    }
                  }
                ],
                "link": {
                  "type": "doc",
                  "id": "data-structures/graph/index"
                }
              },
              {
                "type": "category",
                "label": "Tree",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "data-structures/tree/dfs"
                  },
                  {
                    "type": "doc",
                    "id": "data-structures/tree/root-shifting"
                  }
                ],
                "link": {
                  "type": "doc",
                  "id": "data-structures/tree/index"
                }
              }
            ],
            "algorithms": [
              {
                "type": "doc",
                "id": "algorithms/intro"
              },
              {
                "type": "category",
                "label": "Kadane's Algorithm",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "algorithms/kadanes-algorithm/flip-bits"
                  },
                  {
                    "type": "doc",
                    "id": "algorithms/kadanes-algorithm/maximum-subarray-sum"
                  }
                ],
                "link": {
                  "type": "doc",
                  "id": "algorithms/kadanes-algorithm/index"
                }
              },
              {
                "type": "doc",
                "label": "Monotonic Stack",
                "id": "algorithms/monotonic-stack/index"
              },
              {
                "type": "doc",
                "id": "algorithms/string-algorithms"
              }
            ],
            "standardProblems": [
              {
                "type": "doc",
                "id": "standard-problems/Blind75"
              },
              {
                "type": "doc",
                "id": "standard-problems/CSES ProblemSet"
              }
            ],
            "webDevelopment": [
              {
                "type": "doc",
                "id": "web-development/mongodb"
              },
              {
                "type": "category",
                "label": "JavaScript",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "web-development/JavaScript/promise"
                  },
                  {
                    "type": "doc",
                    "id": "web-development/JavaScript/javascript-scopes"
                  }
                ]
              }
            ],
            "sidebar": [
              {
                "type": "category",
                "label": "Data Structures",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "data-structures/intro"
                  },
                  {
                    "type": "category",
                    "label": "Graph",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "data-structures/graph/connected-components"
                      },
                      {
                        "type": "category",
                        "label": "Bipartite Graph",
                        "collapsible": true,
                        "collapsed": true,
                        "items": [
                          {
                            "type": "doc",
                            "id": "data-structures/graph/bipartite-graph/possible_bipartition"
                          }
                        ],
                        "link": {
                          "type": "doc",
                          "id": "data-structures/graph/bipartite-graph/index"
                        }
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "data-structures/graph/index"
                    }
                  },
                  {
                    "type": "category",
                    "label": "Tree",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "data-structures/tree/dfs"
                      },
                      {
                        "type": "doc",
                        "id": "data-structures/tree/root-shifting"
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "data-structures/tree/index"
                    }
                  }
                ],
                "link": {
                  "type": "generated-index",
                  "description": "5 minutes to learn the most important Data Structures.",
                  "slug": "/category/data-structures",
                  "permalink": "/category/data-structures"
                }
              },
              {
                "type": "category",
                "label": "Algorithms",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "algorithms/intro"
                  },
                  {
                    "type": "category",
                    "label": "Kadane's Algorithm",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "algorithms/kadanes-algorithm/flip-bits"
                      },
                      {
                        "type": "doc",
                        "id": "algorithms/kadanes-algorithm/maximum-subarray-sum"
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "algorithms/kadanes-algorithm/index"
                    }
                  },
                  {
                    "type": "doc",
                    "label": "Monotonic Stack",
                    "id": "algorithms/monotonic-stack/index"
                  },
                  {
                    "type": "doc",
                    "id": "algorithms/string-algorithms"
                  }
                ],
                "link": {
                  "type": "generated-index",
                  "description": "5 minutes to learn the most important Algorithms.",
                  "slug": "/category/algorithms",
                  "permalink": "/category/algorithms"
                }
              },
              {
                "type": "category",
                "label": "Standard Problems",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "standard-problems/Blind75"
                  },
                  {
                    "type": "doc",
                    "id": "standard-problems/CSES ProblemSet"
                  }
                ],
                "link": {
                  "type": "generated-index",
                  "description": "Important patternt to master interviews!",
                  "slug": "/category/standard-problems",
                  "permalink": "/category/standard-problems"
                }
              },
              {
                "type": "category",
                "label": "Web Development",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "web-development/mongodb"
                  },
                  {
                    "type": "category",
                    "label": "JavaScript",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "web-development/JavaScript/promise"
                      },
                      {
                        "type": "doc",
                        "id": "web-development/JavaScript/javascript-scopes"
                      }
                    ]
                  }
                ],
                "link": {
                  "type": "generated-index",
                  "description": "All important concepts of Web Development",
                  "slug": "/category/web-development",
                  "permalink": "/category/web-development"
                }
              }
            ]
          }
        }
      ]
    }
  },
  "docusaurus-plugin-content-blog": {
    "default": {
      "blogSidebarTitle": "Recent posts",
      "blogPosts": [
        {
          "id": "mongodb-tutorial",
          "metadata": {
            "permalink": "/mongodb-tutorial",
            "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/blog/2023-04-24-mongodb-tutorial.mdx",
            "source": "@site/blog/2023-04-24-mongodb-tutorial.mdx",
            "title": "MongoDB Tutorial",
            "description": "MongoDB is a NoSQL document based database. Essentially, all the data in MongoDB is stored in JSON documents that are sorted into a variety of collections based on the type of data. It is one of the most popular NoSQL database options due to its relative ease of use and power. In this article I will be covering a ton of concepts and functions in MongoDB which touch on all the important aspects of MongoDB.",
            "date": "2023-04-24T00:00:00.000Z",
            "formattedDate": "April 24, 2023",
            "tags": [
              {
                "label": "MongoDB",
                "permalink": "/tags/mongo-db"
              },
              {
                "label": "BackEnd",
                "permalink": "/tags/back-end"
              }
            ],
            "readingTime": 14.435,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Ashutosh Gautam",
                "title": "4 üåü CodeChefüî∏Specialist @CodeForces üî∏Full-Stack Web Developer",
                "url": "https://www.linkedin.com/in/ashuthe1/",
                "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
                "key": "Ashutosh"
              }
            ],
            "frontMatter": {
              "slug": "mongodb-tutorial",
              "title": "MongoDB Tutorial",
              "authors": "Ashutosh",
              "tags": [
                "MongoDB",
                "BackEnd"
              ]
            },
            "nextItem": {
              "title": "Cp Roadmap for beginners and People below Specialist",
              "permalink": "/cp-roadmap-for-beginners-and-people-below-specialist"
            }
          },
          "content": "`MongoDB` is a NoSQL document based database. Essentially, all the data in MongoDB is stored in JSON documents that are sorted into a variety of collections based on the type of data. It is one of the most popular NoSQL database options due to its relative ease of use and power. In this article I will be covering a ton of concepts and functions in MongoDB which touch on all the important aspects of MongoDB.\n\n## Getting Started\nIn order to get started with MongoDB we first need to install MongoDB to our computers. You also need a way to interact with MongoDB as well which is where the command line tool Mongosh comes in. When installing MongoDB make sure to download the community edition and not the enterprise edition. Below are download links for both of these tools.\n\nMongoDB: https://docs.mongodb.com/manual/installation <br/>\nMongosh: https://docs.mongodb.com/mongodb-shell/install\n\nOnce you install these two tools just open up a terminal and type mongosh to start working with MongoDB.\n\n<!--truncate-->\n\n## Terminology\nIn order to understand MongoDB we first need to talk about some basic terminology related to MongoDB databases.\n\n# Database\nThe first term you need to understand is database. A database is simply a container for collections. A database in MongoDB is the same conceptually as a database in SQL and usually a project will have one database full of different collections.\n\n# Collection\nA collection is a grouping of documents inside a database. This is the same conceptually as tables in a SQL database. Usually you will have one collection per data model. For example, your app may have users, posts, and products collections.\n\n# Document\nA document is just a record inside of a collection. This is conceptually the same as a row in a SQL table. A document generally represents one single object within a collection. In MongoDB a document is essentially just a JSON object.\n\n# Field\nThe last piece of terminology you need to understand is fields. A field is just a key value pair within a document. This is conceptually the same as a column in SQL. Each document contains a number of fields which contain information such as name, address, hobbies, etc. An important difference between SQL and MongoDB is that a field can contain values such as JSON objects and arrays instead of just strings, numbers, booleans, etc. Also, MongoDB documents can have different fields defined within the same collection. In SQL all rows in a table must have the same columns, but in MongoDB one document in the users collection could have the fields name, and age, while another user document could have the fields name, address, and hobbies.\n\n## Basic Commands\nBefore we start dealing with data we first need to understand a few basic commands that allow us to deal with databases.\n\n# `mongosh`\nThe first command is the 'mongosh` command. This command is run in the terminal and gives us direct access to our local MongoDB installation. All future commands in this article will be run within this mongosh prompt.\n\n# `show dbs`\nThe show dbs command is a simple command that shows all MongoDB databases. If you run this you will notice that there are already some databases that were created when you installed MongoDB.\n\n# `use <dbname>`\nThis command lets you switch to a database based on the dbname variable. For example, use mydb will switch you to the mydb database. If there is no database with that name it will still swap you to that db and if you later add any data it will automatically create the db and add the data to it. Unlike SQL, MongoDB has no commands to create data/collections since they are automatically created when you add data.\n\n# `db`\nThis command just prints out the current database name.\n\n# `cls`\nThis command clears the terminal screen.\n\n# `show collections`\nIf you are connected to a database you can run show collections to print out information on all the collections in that database.\n\n# `db.dropDatabase()`\nThis command will delete the current database and all the data within it. You will also notice this command looks a lot like JavaScript code. This is actually true of many commands in MongoDB. This is nice since if you are used to JavaScript it can make understanding MongoDB quite a bit easier.\n\n# `exit`\nThe last basic command is the exit command which just exits the mongosh session that you started with the mongosh command.\n\n## CRUD Methods\nThe following commands will be all the Create, Read, Update, and Delete commands you need to know in MongoDB. All of these commands will be run on a specific collection within a specific database. For example to get all the records in the users table within the current db you would write `db.users.find()`.\n\n# Create\nCreating documents in MongoDB is actually pretty simple since there are only two methods to do so and they both are very similar.\n\n# `insertOne`\nThis function takes a single object and creates a document with the specified information within the specified collection. You also notice we don't pass an ID when we create documents. This is because every MongoDB document automatically has an `_id` property added to it with a unique id.\n\n```js\n// Insert a user with the name Ashutosh\ndb.users.insertOne({ name: \"Ashutosh\" })\n```\n# `insertMany`\nThis function works just like `insertOne`, but it takes an array of objects to be inserted instead.\n\n```js\n// Insert a user with the age of 26 and a second user with the name Ashutosh\ndb.users.insertMany([{ age: 26 }, { name: \"Ashutosh\" }])\n```\n# Read\nReading data within MongoDB is much more complicated and is where almost all the confusion around MongoDB comes from.\n\n# `find`\nIf you want to get all the documents within a single collection you can use the `find` method with no additional parameters.\n```js\n// Get all users\ndb.users.find()\n```\n\n# `find(<filterObject>)`\nGenerally when you get documents you only want to get some of them. If you pass an object to the `find` method it will return all documents that match that filter object. By default the filter object will do equality comparisons and if you pass multiple fields in the same filter object it will only return documents that match all the fields in the filter. Later in this article I will be covering some of the more complex filter options you can use which is where most of the complexity of MongoDB comes from.\n\n```js\n// Get all users with the name Ashutosh\ndb.users.find({ name: \"Ashutosh\" })\n\n// Get all users whose address field has a zip field with the value 12345\ndb.users.find({ \"address.zip\": \"12345\" })\n```\n# `find(<filterObject>, <selectObject>)`\nThe final way to use the `find` method is by passing a second object to select which fields you want returned. The object contains a key which is the field and a value of either 0 or 1 to determine if that field is returned or not. By default the `_id` property is always returned unless specifically told not.\n\n```js\n// Get all users with the name Ashutosh and return the name, age, and _id fields\ndb.users.find({ name: \"Ashutosh\" }, { name: 1, age: 1 })\n\n// Get all users and return all fields except the age field\ndb.users.find({}, { age: 0 })\n```\n# `findOne`\nThis is the same as find in every way except it just returns the first document that matches the filter.\n\n```js\n// Get the first user with the name Ashutosh\ndb.users.findOne({ name: \"Ashutosh\" })\n```\n# `countDocuments`\nThis final method returns the count of all documents that match the filter passed to it.\n\n```js\n// Get the count of users with the name Ashutosh\ndb.users.countDocuments({ name: \"Ashutosh\" })\n```\n\n# Update\nUpdating documents in MongoDB is a bit more complex than in SQL since there are actually many different ways you can update a document.\n\n# `updateOne`\nThe main way to update a document is with the `updateOne` function. This will update the first document that matches the filter passed to it and will then update the document based on the information passed in the second parameter to `updateOne`. This second parameter takes a bunch of different options which we will cover later in this article.\n```js\n// Update the age of the first user with an age of 20 to 21\ndb.users.updateOne({ age: 20 }, { $set: { age: 21 } })\n```\n# `updateMany`\nThis works exactly the same as `updateOne`, but it will update all documents that match the filter object instead of just the first.\n\n```js\n// Update the age of all users with the age of 14 by adding 2 to their age\ndb.users.updateMany({ age: 14 }, { $incr: { age: 2 } })\n```\n# `replaceOne`\nThis works similarly to `updateOne`, but it will instead replace the entire document and not just update specific fields. Generally this is not something you want to do as it will delete all fields in the object (except the id field) that are not specified within the object passed to `replaceOne`.\n```js\n// Replace the first user with an age of 14 with an object that only has a name field \ndb.users.replaceOne({ age: 14 }, { name: \"Ashutosh\" })\n```\n\n# Delete\nUpdate and read were pretty complicated so luckily delete is very simple.\n\n# `deleteOne`\nThis method will delete the first object that matches the filter object passed to it.\n```js\n// Delete the first user with the age of 20\ndb.users.deleteOne({ age: 20 })\n```\n# `deleteMany`\nThis is the same as deleteOne but it will delete all documents that match the filter object instead of just one.\n```js\n// Delete all users with the age of 14\ndb.users.deleteMany({ age: 14 })\n```\n\n## Advanced MongoDB Concepts\nThe above CRUD methods will cover your basic MongoDB needs, but there are a few ways you can modify these methods to make them even more useful.\n\n# Complex Filter Object\nThe first way to make the above methods more useful is to expand on the filter object. Every single read, update, and delete method we covered takes a filter object as its first parameter. This filter object determines which documents are read, updated, or deleted, but so far we can only do exact matches. This is where complex filter objects come in. With MongoDB you can pass an object as the value of a field instead of a value and that object can specify a bunch of information about how to filter that field. You can also combine together and nest filters as much as you want.\n\n# `$eq`\nThe easiest complex filter to understand is the $eq filter since it checks for equality and works exactly the same as how our simple filters do.\n```js\n// This is essentially the same as db.users.find({ name: \"Ashutosh\" })\ndb.users.find({ name: { $eq: \"Ashutosh\" }})\n```\n# `$neq`\nThe `$neq` filter is the exact opposite of $eq and checks for inequality.\n```js\n// Get all users with a name other than Ashutosh\ndb.users.find({ name: { $neq: \"Ashutosh\" }})\n```\n# `$gt / $gte`\nThese filters check for when a value is greater than or greater than or equal to another value.\n```js\n// Get all users with an age greater than 18\ndb.users.find({ age: { $gt: 18 }})\n\n// Get all users with an age greater than or equal to 21\ndb.users.find({ age: { $gte: 21 }})\n```\n# `$lt / $lte`\nThis is the same as $gt and $gte except for checking less than and less than or equal to.\n```js\n// Get all users with an age less than 18\ndb.users.find({ age: { $lt: 18 }})\n\n// Get all users with an age less than or equal to 21\ndb.users.find({ age: { $lte: 21 }})\n```\n# `$in`\nThis will return all documents that match one of the values in the array.\n```js\n// Get all users with the name Ashutosh or John\ndb.users.find({ name: { $in: [\"Ashutosh\", \"John\"] }})\n```\n# `$nin`\nThis is the opposite of $in and returns all documents with values not in the array.\n```js\n// Get all users with a name other than Ashutosh or John\ndb.users.find({ name: { $nin: [\"Ashutosh\", \"John\"] }})\n```\n# `$and`\nThis checks that all conditions in the array are true. This is not normally needed, though, since passing multiple key value pairs to the same filter object by default does an and operation.\n```js\n// Get all users with the name Ashutosh and the age 22\ndb.users.find({ $and: [{ name: \"Ashutosh\" }, { age: 22 }] })\n// This is the same as db.users.find({ age: 22, name: \"Ashutosh\" })\n```\n# `$or`\nThis is the same as $and, but it does an or check instead of an and check.\n```js\n// Get all users with the name Ashutosh or the age 22\ndb.users.find({ $or: [{ name: \"Ashutosh\" }, { age: 22 }] })\n```\n# `$not`\nThis negates the filter passed to it. Again this is generally not needed much as you can create pretty much the same filter using other filter combinations.\n```js\n// Get all users with a name other than Ashutosh\ndb.users.find({ $name: { $not: { $eq: \"Ashutosh\" }}})\n```\n# `$exists`\nThis will filter documents based on if a field exists on the document or not. This will only check the field, though, and not the value. That means if a document has a field with a value of null it will still show up in the $exists query.\n```js\n// Get all users with a name field defined\ndb.users.find({ $name: { $exists: true }})\n\n// Get all users without a name field\ndb.users.find({ $name: { $exists: false }})\n```\n# `$expr`\nThis filter allows you to do comparisons between multiple different fields on your document.\n```js\n// Get all users that have a balance greater than their debt\ndb.users.find({ $expr: { $gt: [\"$balance\", \"$debt\"] } })\n```\n\n# Complex Update Object\nWhen talking about updates I mentioned that you can pass a lot of information to the update function that isn't just field values. In this section I will talk about all these update options that you can use to update your objects. You can also use more than one of these options at the same time to do really complex updates.\n\n# `$set`\nIf you want to just change the value of a field from one value to another the $set option is your best option.\n```js\n// Update the first user with an age of 12 to also have the name Ashutosh\ndb.users.updateOne({ age: 12 }, { $set: { name: \"Ashutosh\" } })\n```\n# `$inc`\nIf you want to increment/decrement a number field you can use the $inc option and pass it a number to add to the given field.\n```js\n// Update the first user with an age of 12 by subtracting 2 from its age\ndb.users.updateOne({ age: 12 }, { $inc: { age: -2 } })\n```\n# `$rename`\nThis lets you rename a field.\n```js\n// Rename the age field to years on all users\ndb.users.updateMany({}, { $rename: { age: \"years\" } })\n```\n# `$unset``\nThis lets you remove a field from a document. You must pass an empty string as the value for the field you want to remove.\n```js\n// Remove the age field from all users with the age of 12\ndb.users.updateOne({ age: 12 }, { $unset: { age: \"\" } })\n```\n# `$push`\nThis lets you add a value to an array field.\n```js\n// Add John to the friends array for all users\ndb.users.updateMany({}, { $push: { friends: \"John\" } })\n```\n# `$pull`\nThis is the opposite of $push and removes a value from an array field.\n```js\n// Remove John from the friends array for all users\ndb.users.updateMany({}, { $pull: { friends: \"John\" } })\n```\n\n# Read Modifiers\nThe last concept I want to talk about with MongoDB is the ability to modify read queries. These methods can be added to the end of any read operation and will modify how the results are returned. You can also chain multiple of these modifiers onto one single read query if you want.\n\n# `$sort`\nThis will sort the results of read query. The results will be sorted in ascending order if you pass 1 to the field and descending order if you pass -1. Also if you want to sort by multiple fields they will be sorted in the order you pass them to sort.\n```js\n// Get all users sorted by name in ascending order and then if any names are the same sort by age in descending order\ndb.users.find().sort({ name: 1, age: -1 })\n```\n# `$limit`\nThis will only return the number of documents you tell it to.\n```js\n// Get the first 2 users\ndb.users.find().limit(2)\n```\n# `$skip`\nThis will skip a set number of documents from the beginning of the find. This is useful in combination with limit to do pagination.\n```js\n// Get all users except the first 4\ndb.users.find().skip(4)\n```\n\n## Conclusion\nMongoDB has tons of methods and complexity, but if you understand everything in this article you have everything you need to work with MongoDB\n\n![Github Views](https://komarev.com/ghpvc/?username=ashuthe1)"
        },
        {
          "id": "cp-roadmap-for-beginners-and-people-below-specialist",
          "metadata": {
            "permalink": "/cp-roadmap-for-beginners-and-people-below-specialist",
            "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/blog/2023-04-17-cp-roadmap-for-beginners-and-people-below-specialist.mdx",
            "source": "@site/blog/2023-04-17-cp-roadmap-for-beginners-and-people-below-specialist.mdx",
            "title": "Cp Roadmap for beginners and People below Specialist",
            "description": "I come across folks who seek guidance for progressing in cp and most of them are pupils / newbies,",
            "date": "2023-04-17T00:00:00.000Z",
            "formattedDate": "April 17, 2023",
            "tags": [
              {
                "label": "CP",
                "permalink": "/tags/cp"
              },
              {
                "label": "Roadmap",
                "permalink": "/tags/roadmap"
              },
              {
                "label": "DSA",
                "permalink": "/tags/dsa"
              },
              {
                "label": "CodeChef",
                "permalink": "/tags/code-chef"
              },
              {
                "label": "CodeForces",
                "permalink": "/tags/code-forces"
              }
            ],
            "readingTime": 6.09,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Ashutosh Gautam",
                "title": "4 üåü CodeChefüî∏Specialist @CodeForces üî∏Full-Stack Web Developer",
                "url": "https://www.linkedin.com/in/ashuthe1/",
                "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
                "key": "Ashutosh"
              }
            ],
            "frontMatter": {
              "slug": "cp-roadmap-for-beginners-and-people-below-specialist",
              "title": "Cp Roadmap for beginners and People below Specialist",
              "authors": "Ashutosh",
              "tags": [
                "CP",
                "Roadmap",
                "DSA",
                "CodeChef",
                "CodeForces"
              ]
            },
            "prevItem": {
              "title": "MongoDB Tutorial",
              "permalink": "/mongodb-tutorial"
            },
            "nextItem": {
              "title": "232. Implement Queue using Stacks",
              "permalink": "/leetcode/implement-queue-using-stacks"
            }
          },
          "content": "I come across folks who seek guidance for progressing in cp and most of them are pupils / newbies, \nbecause when you reach a Specialist you yourself know what has to be done to progress further . So for those here is some advice. \n\nSo let's start with Beginners or People with rating 800 - 1200. <br/>\nIf your graph looks something like below profile , you are at level 1 , your first goal should be reaching <br/> specialist -> 1400 rating . \n\n<!--truncate-->\n\n![image](https://user-images.githubusercontent.com/86846633/232587990-4b17bdf4-8eef-40a0-9fe2-88772605d39f.png)\n\nTopics needed to attain level 2 (>=1400) in order of their importance.\n\n0) stl in c++ , Collections in Java or equivalent . <br/>\n1) Basic maths , basic logic  <br/>\n2) Searching - Sorting , greedy , two pointers ,sliding window  <br/>\n3) Implementation , stl based  <br/>\n4) Binary search ( very important and a saviour) <br/> \n5) Number theory  <br/>\n6) Basic bit manipulation and basic combinatorics. (very basic)\n\n## Practice strategy \nTwo types of practice are needed :-  <br/>\n1) to build critical thinking / problem solving / application of concepts known.  <br/>\n2) to learn new concepts, tricks and standard problems.  <br/>\n\nFor the first kind of practice you have to solve 40 each in the rating range 800-1400. You can skip a level if you are way too comfortable with it , but don't do more than 50 of any level and waste your time , most beginners do 100-150 800‚Äôs which are completely wasted as in the above profile, the person has done 100 800‚Äôs .\nSo do 40 each 800->900->1000->1100->1200->1300->1400.\nNow at this point you would be able to do A,B and C sometimes.\nNow do 10 more of each if you want .\nNow if you do this you will reach near 1400 . \n\n## Learning strategy\nYou can learn on the fly by just reading editorials and solutions , but it would be more helpful if you spare some time for learning new things.\nFor the topics listed above just search on youtube or google about what are those algos now for doing some standard problems. Resource is Cses Problemset - those are educative and standard problems.\nCompetitive programming handbook - very soothing book .\nLuv‚Äôs youtube channel has a competitive programming playlist\nWhich is also a nice resource to learn things from beginners' pov . \nYou can actually follow any thing you wish just search on google / yt try reading/ watching if you don't get ,-> switch , after two three tries , you will find something which works for you .\n\nBottomline - practice consistently and 40/50 of each rating till 1400 and learn some standard algos , tricks .\n\n\n\n\n\n\n\n\nFrom level 2 (1400) to level 3 (1500-Expert) .\n\nTopics : \nStrong implementation  , speed , accuracy and brute force.\nBinary Search(very important ),\nNumber Theory , \nBit manipulation and Combinatorics ( basic - intermediate)\nTrees / graph -> basic ( questions <=1600/1700 rated)\nDynamic Programming ( 1600-1700 ) , standard problems.\n\nPractice strategy\n1)  For first kind of practice\nnow you need to practise 40 each in 1500 - 1600\nThen 10 each of both .\nNow if you have 50 of each till 1600 begin with 1700 , 1800 \nStrategy remains the same 40 each then after 10 more for each .\n2)  For second kind - Learning strategy \nLearn binary search on answer and everything related to binary search \nDo some good problems on bit manipulation and combinatorics as you encounter them.\nStart learning dp and trees side by side or one after from youtube or wherever you wish ( I started trees from codencode and dp from Aditya Verma) .\nCan refer Cses for standard problems. \n\nBottomline:- If you do this you will reach or have potential to reach expert(>1600) .\n\n\n\n3) For people being specialist and want to reach Expert \n\nYou have to do 40-50 each till 1800 .\n When you complete 1800 then you might reach Expert soon , \nI take it like this - you should solve <=x+200 in problems set to reach a rating x in contests .\nTopics to be covered - Trees ,Graphs, Dp , Segment trees/Range query data structures.\nLearn various useful graphs algos like mst, toposort etc , you should be doing plenty of problems on dp , you should learn segment trees and solve questions on it.\nSo all in all you have to master these topics and come to intermediate or above intermediate level .\nResources- Cp algorithms , Competitive programming handbook,\nAnd tbh any good tutorial , web or video based which you like ,     doesn't matter much .\n\n\n\n## Necessary points to keep in mind  :\n\n1) Participate in every contest , don't care about ratings till you reach an expert. Learnings in one contest = learnings for one week in practice .\n\n2) Always upsolve the problem you couldn't do (<=C in cf div2 rounds) and watch others' solutions who are better rated / your idols -how , why they did that problem in that way ,(lol just stalk their solutions ).\n\n3) In a month if you do 100 problems it's great , you should tap on your shoulder. That costs like 3 problems a day, very much doable if consistent. \n\n4) If you feel uncomfortable with the new rating don‚Äôt back out, it's fine . \nWhen I moved to a new rating I did the first 20 mostly by reading editorials, \ntaking hints etc . You can do the same but just understand the intuition behind it.\nAlso you will come across some problem where you won‚Äôt understand anything even after reading \neditorial and trying your way out . In such a situation , leave that problem for the future or ignore it for  sometime but don‚Äôt waste your day on that one problem .\n5) Make a habit of learning some algo or doing some standard tasks like cses too.\n\n6) Be consistent , be confident , and perform in contests and if couldnt analyse your mistakes.\n\n7) One more golden advice in each question is to try to extract some conclusions/ some facts / some standard knowledge which you can use in other problems too. For example median is the point which has the least sum of difference from n points . Anything, the bottomline is that from each problem you should try to extract some takeaways which you can use in other problems too. \n\n8) Uplift yourself no matter what , even if you are on bottom of rank list just know that , you are still the best , don‚Äôt be too harsh on yourself because-there is whole world against  you and at the end of the day It has to be you on your side ,  only you are there to pamper yourself so be easy on yourself , just learn from your mistakes and remember everyday is a new day .\n\n9) Save the algorithms or implementation in files or snippets so that you can revisit , for example I have many files named as , graph_algorithms, dp , utility functions , string algos, range based data structures etc. So when I forget something I revisit that also I can use codes in contests.\n\n## Who am I ? \n![Github Views](https://komarev.com/ghpvc/?username=ashuthe1) <br/>\nhttps://www.codechef.com/users/ashuthe1x ."
        },
        {
          "id": "leetcode/implement-queue-using-stacks",
          "metadata": {
            "permalink": "/leetcode/implement-queue-using-stacks",
            "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/blog/leetcode-daily/2022-12-16-implement-queue-using-stacks.mdx",
            "source": "@site/blog/leetcode-daily/2022-12-16-implement-queue-using-stacks.mdx",
            "title": "232. Implement Queue using Stacks",
            "description": "Problem Statement",
            "date": "2022-12-16T00:00:00.000Z",
            "formattedDate": "December 16, 2022",
            "tags": [
              {
                "label": "LeetCode",
                "permalink": "/tags/leet-code"
              },
              {
                "label": "Leetcode Daily",
                "permalink": "/tags/leetcode-daily"
              },
              {
                "label": "DSA",
                "permalink": "/tags/dsa"
              },
              {
                "label": "Stack",
                "permalink": "/tags/stack"
              },
              {
                "label": "Queue",
                "permalink": "/tags/queue"
              }
            ],
            "readingTime": 3.23,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Ashutosh Gautam",
                "title": "4 üåü CodeChefüî∏Specialist @CodeForces üî∏Full-Stack Web Developer",
                "url": "https://www.linkedin.com/in/ashuthe1/",
                "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
                "key": "Ashutosh"
              }
            ],
            "frontMatter": {
              "slug": "leetcode/implement-queue-using-stacks",
              "title": "232. Implement Queue using Stacks",
              "authors": "Ashutosh",
              "tags": [
                "LeetCode",
                "Leetcode Daily",
                "DSA",
                "Stack",
                "Queue"
              ]
            },
            "prevItem": {
              "title": "Cp Roadmap for beginners and People below Specialist",
              "permalink": "/cp-roadmap-for-beginners-and-people-below-specialist"
            },
            "nextItem": {
              "title": "Longest Common Subsequence, LeetCode",
              "permalink": "/leetcode/longest-common-subsequence"
            }
          },
          "content": "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Problem Statement\n\nImplement a first in first out (FIFO) queue using only two stacks.\nThe implemented queue should support all the functions of a normal\nqueue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n`void push(int x)` Pushes element x to the back of the queue.\n`int pop()` Removes the element from the front of the queue and returns it.\n`int peek()` Returns the element at the front of the queue.\n`boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n<!--truncate-->\n\n**Notes:**\n\n- You must use only standard operations of a stack, which means only `push to top`,\n`peek/pop from top`, `size`, and `is empty` operations are valid.\n- Depending on your language, the stack may not be supported natively. You may\nsimulate a stack using a list or deque (double-ended queue) as long as you use\nonly a stack's standard operations.\n\nExample 1:\n```text\nInput:\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput:\n[null, null, null, 1, 1, false]\n\nExplanation:\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\nConstraints:\n- `1 <= x <= 9`\n- At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.\n- All the calls to `pop` and `peek` are valid.\n\n## Follow Up\nCan you implement the queue such that each operation is [amortized](https://en.wikipedia.org/wiki/Amortized_analysis)\n`O(1)` time complexity? In other words, performing `n` operations will take\noverall `O(n)` time even if one of those operations may take longer.\n\n## Explanation\n\nProperties of Queue:\n```mermaid\nflowchart LR;\n\nqueue[Queue Data Structure];\npush((Push));\npeek((Peek));\npop((Pop));\nfront[Front];\nback[Back];\n\npop --- front --- queue --- back --- push;\npeek --- front;\n```\n\nProperties of Stack:\n```mermaid\nflowchart LR;\n\nstack[Stack Data Structure];\npush((Push));\npeek((Peek));\npop((Pop));\nfront[Front];\nback[Back];\n\nfront --- stack --- back --- push;\nback --- pop;\nback --- peek;\n```\n\nInorder to create queue using stack, we can use combination of 2 stacks (say `stack1`, `stack2`);\n\n### Queue: Push\n- push new element to `stack1`\n- oldest element pushed will be in the bottom of stack\n- newest element pushed will be on the top of stack\n\n### Queue: Peek\n- IF `stack2` is empty then oldest element will be at the\nbottom of `stack1` else oldest element will be on top of `stack2`\n```text\nIF stack2 is empty\n    WHILE stack1 is not empty\n        pop element from stack1\n        push element into stack2\n```\n- Now, oldest element will always be on the top of `stack2`\n\n### Queue: Pop\n- same as finding the peek, then just pop peek element from `stack2`.\n- after, pop operation on `stack2`, 2nd oldest will again come on top of `stack2`.\n\n## Solution\n\n<Tabs>\n\n<TabItem value=\"cpp\" label=\"C++ Two User Stack\">\n\n```cpp title='C++ Solution using Two User Defined Stack'\nclass MyQueue {\nprivate:\n    stack<int> s1, s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty()) {\n            while(!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int ans = s2.top();\n        s2.pop();\n        return ans;\n    }\n    \n    int peek() {\n        if(s2.empty()) {\n            while(!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.size() + s2.size() == 0;\n    }\n};\n\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\nTime Complexity:\n- Push: O(1)\n- Pop: O(N), amortized: O(1)\n- Peek: O(N), amortized: O(1)\n\nSpace Complexity: O(N)\n\n</TabItem>\n\n</Tabs>\n\n\n## Related Problems\n- [Implement Stack using Queues - GeeksforGeeks](https://www.geeksforgeeks.org/implement-stack-using-queue/)\n- [225. Implement Stack using Queues - LeetCode](https://leetcode.com/problems/implement-stack-using-queues/)\n\n## References\n- [Queue using Stacks - GeeksforGeeks](https://www.geeksforgeeks.org/queue-using-stacks/)\n\n## Links\n- [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)"
        },
        {
          "id": "leetcode/longest-common-subsequence",
          "metadata": {
            "permalink": "/leetcode/longest-common-subsequence",
            "editUrl": "https://github.com/ashuthe1/LogicBehindCode/tree/main/blog/leetcode-daily/2022-12-15-longest-common-subsequence.mdx",
            "source": "@site/blog/leetcode-daily/2022-12-15-longest-common-subsequence.mdx",
            "title": "Longest Common Subsequence, LeetCode",
            "description": "Problem Statement",
            "date": "2022-12-15T00:00:00.000Z",
            "formattedDate": "December 15, 2022",
            "tags": [
              {
                "label": "LeetCode",
                "permalink": "/tags/leet-code"
              },
              {
                "label": "Leetcode Daily",
                "permalink": "/tags/leetcode-daily"
              },
              {
                "label": "DSA",
                "permalink": "/tags/dsa"
              },
              {
                "label": "Dynamic Programming",
                "permalink": "/tags/dynamic-programming"
              },
              {
                "label": "String",
                "permalink": "/tags/string"
              }
            ],
            "readingTime": 3.105,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Ashutosh Gautam",
                "title": "4 üåü CodeChefüî∏Specialist @CodeForces üî∏Full-Stack Web Developer",
                "url": "https://www.linkedin.com/in/ashuthe1/",
                "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
                "key": "Ashutosh"
              }
            ],
            "frontMatter": {
              "slug": "leetcode/longest-common-subsequence",
              "title": "Longest Common Subsequence, LeetCode",
              "authors": "Ashutosh",
              "tags": [
                "LeetCode",
                "Leetcode Daily",
                "DSA",
                "Dynamic Programming",
                "String"
              ]
            },
            "prevItem": {
              "title": "232. Implement Queue using Stacks",
              "permalink": "/leetcode/implement-queue-using-stacks"
            }
          },
          "content": "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Problem Statement\n\nGiven two strings `text1` and `text2`, return the length of their *longest common subsequence*. If there is no common subsequence, return `0`.\n\nA *subsequence* of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n- For example, `\"ace\"` is a subsequence of `\"abcde\"`.\n\nA *common subsequence* of two strings is a subsequence that is common to both strings. \n\n<!--truncate-->\n\nExample 1:\n```text\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\nExample 2:\n```text\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\nExample 3:\n```text\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\nConstraints:\n- `1 <= text1.length, text2.length <= 1000`\n- `text1` and `text2` consist of only lowercase English characters.\n\n## Explanation\n\nLet `i1` and `i2` be two pointer pointing at `current` index in string `s1` and `s2` respectively.\n\nlet `dp(i1, i2, s1, s2)` denotes the length of longest common subsequence in string `s1[i1...n1]` and `s2[i2...n2]`.\n\nIf _i1 == n1_, implies s1[i1....n1] is empty.\n\n**Base Case:** longest common subsequence of any string with empty string is 0.\nTherefore is any of _i1 == n1_ or _i2 == n2_ return `0`.\n\nNow, for any `i1` and `i2` there are 2 possibilities.\n\n```mermaid\ngraph TD;\n    root[\"(i1, i2)\"];\n    eq[\"s1[i1] == s2[i2]\"];\n    nq[\"s1[i1] != s2[i2]\"];\n\n    root --> eq -- Pick --> Pick[\"Consider Current Characters in Subsequence\"] --Recursive Call--> next[\"(i1+1, i2+1)\"];\n    eq -- Skip --> Skip[\"Skip Current Characters either from s1 or s2\"];\n\n    root --> nq -- Skip --> Skip;\n\n    Skip --Recursive Call--> next_i1[\"(i1+1, i2)\"];\n    Skip --Recursive Call--> next_i2[\"(i1, i2+1)\"];\n```\n\n## Solution\n\n<Tabs>\n\n<TabItem value=\"cpp1\" label=\"C++ Recursive\">\n\n```cpp title='CPP: Recursive Brute Force Solution [Time Limit Exceeded]'\nclass Solution {\nprivate:\n    int dp(int i1, int i2, string &s1, string &s2) {\n        int n1 = s1.size();\n        int n2 = s2.size();\n\n        // Base Case\n        if(i1 == n1 || i2 == n2) return 0;\n\n        if(s1[i1] == s2[i2]) {\n            return max({\n                dp(i1+1, i2+1, s1, s2) + 1,\n                dp(i1, i2+1, s1, s2),\n                dp(i1+1, i2, s1, s2),\n            });\n        }\n        else {\n            return max({\n                dp(i1, i2+1, s1, s2),\n                dp(i1+1, i2, s1, s2),\n            });\n        }\n    }\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        return dp(0, 0, text1, text2);\n    }\n};\n```\n\nm               |n                  | Time Complexity  | Space Complexity\n----------------|-------------------|------------------|-----------------\nsize of string 1|size of string 2   | O(max(m,n)\\*m\\*n)| O(max(m,n))\n\n</TabItem>\n\n<TabItem value=\"cpp2\" label=\"C++ Recursive DP\">\n\n```cpp title='CPP: Recursive + Memoization [Accepted]'\nclass Solution {\nprivate:\n    int dp(int i1, int i2, string &s1, string &s2, vector<vector<int>> &cache) {\n        int n1 = s1.size();\n        int n2 = s2.size();\n\n        // Base Case\n        if(i1 == n1 || i2 == n2) return 0;\n\n        if(cache[i1][i2] != -1) return cache[i1][i2];\n\n        if(s1[i1] == s2[i2]) {\n            return cache[i1][i2] = max({\n                dp(i1+1, i2+1, s1, s2, cache) + 1,\n                dp(i1, i2+1, s1, s2, cache),\n                dp(i1+1, i2, s1, s2, cache),\n            });\n        }\n        else {\n            return cache[i1][i2] = max({\n                dp(i1, i2+1, s1, s2, cache),\n                dp(i1+1, i2, s1, s2, cache),\n            });\n        }\n    }\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector<vector<int>> cache(text1.size(), vector<int>(text2.size(), -1));\n        return dp(0, 0, text1, text2, cache);\n    }\n};\n```\n\n\nm               |n                  | Time Complexity  | Space Complexity\n----------------|-------------------|------------------|-----------------\nsize of string 1|size of string 2   | O(m*n)           | O(m*n)\n\n</TabItem>\n\n</Tabs>\n\n\n## Related Problems\n- [Longest Common Substring](https://leetcode.com/discuss/interview-question/1273766/longest-common-substring)\n- [1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/)\n- [1062. Longest Repeating Substring](https://leetcode.com/problems/longest-repeating-substring/)\n- [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)\n\n## References\n- [Longest common subsequence Recursive - YouTube, Aditya Verma](https://youtu.be/4Urd0a0BNng)\n- [Longest common subsequence Tabular - YouTube, Tushar Roy](https://youtu.be/NnD96abizww)"
        }
      ],
      "blogListPaginated": [
        {
          "items": [
            "mongodb-tutorial",
            "cp-roadmap-for-beginners-and-people-below-specialist",
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "metadata": {
            "permalink": "/",
            "page": 1,
            "postsPerPage": 10,
            "totalPages": 1,
            "totalCount": 4,
            "blogDescription": "Blog",
            "blogTitle": "Blog"
          }
        }
      ],
      "blogTags": {
        "/tags/mongo-db": {
          "label": "MongoDB",
          "items": [
            "mongodb-tutorial"
          ],
          "permalink": "/tags/mongo-db",
          "pages": [
            {
              "items": [
                "mongodb-tutorial"
              ],
              "metadata": {
                "permalink": "/tags/mongo-db",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/back-end": {
          "label": "BackEnd",
          "items": [
            "mongodb-tutorial"
          ],
          "permalink": "/tags/back-end",
          "pages": [
            {
              "items": [
                "mongodb-tutorial"
              ],
              "metadata": {
                "permalink": "/tags/back-end",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/cp": {
          "label": "CP",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/cp",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/cp",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/roadmap": {
          "label": "Roadmap",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/roadmap",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/roadmap",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/dsa": {
          "label": "DSA",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist",
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/dsa",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist",
                "leetcode/implement-queue-using-stacks",
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/dsa",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 3,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/code-chef": {
          "label": "CodeChef",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/code-chef",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/code-chef",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/code-forces": {
          "label": "CodeForces",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/code-forces",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/code-forces",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/leet-code": {
          "label": "LeetCode",
          "items": [
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/leet-code",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks",
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/leet-code",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 2,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/leetcode-daily": {
          "label": "Leetcode Daily",
          "items": [
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/leetcode-daily",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks",
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/leetcode-daily",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 2,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/stack": {
          "label": "Stack",
          "items": [
            "leetcode/implement-queue-using-stacks"
          ],
          "permalink": "/tags/stack",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks"
              ],
              "metadata": {
                "permalink": "/tags/stack",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/queue": {
          "label": "Queue",
          "items": [
            "leetcode/implement-queue-using-stacks"
          ],
          "permalink": "/tags/queue",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks"
              ],
              "metadata": {
                "permalink": "/tags/queue",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/dynamic-programming": {
          "label": "Dynamic Programming",
          "items": [
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/dynamic-programming",
          "pages": [
            {
              "items": [
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/dynamic-programming",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/string": {
          "label": "String",
          "items": [
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/string",
          "pages": [
            {
              "items": [
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/string",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        }
      },
      "blogTagsListPath": "/tags"
    }
  },
  "docusaurus-plugin-content-pages": {
    "default": null
  },
  "docusaurus-plugin-debug": {},
  "docusaurus-theme-classic": {},
  "docusaurus-theme-mermaid": {},
  "docusaurus-bootstrap-plugin": {},
  "docusaurus-mdx-fallback-plugin": {}
}