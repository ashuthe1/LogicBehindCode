{
  "docusaurus-plugin-content-docs": {
    "default": {
      "loadedVersions": [
        {
          "versionName": "current",
          "label": "Next",
          "banner": null,
          "badge": false,
          "noIndex": false,
          "className": "docs-version-current",
          "path": "/",
          "tagsPath": "/tags",
          "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs",
          "editUrlLocalized": "https://github.com/ashuthe1/blog/tree/main/i18n/en/docusaurus-plugin-content-docs/current",
          "isLast": true,
          "routePriority": -1,
          "sidebarFilePath": "/home/ashuthe1/projects/personal/AshutoshBlogs/sidebars.js",
          "contentPath": "/home/ashuthe1/projects/personal/AshutoshBlogs/docs",
          "contentPathLocalized": "/home/ashuthe1/projects/personal/AshutoshBlogs/i18n/en/docusaurus-plugin-content-docs/current",
          "docs": [
            {
              "unversionedId": "algorithms/intro",
              "id": "algorithms/intro",
              "title": "Introduction to Algorithms",
              "description": "The word Algorithm means ‚ÄùA set of finite rules or instructions to be followed in calculations or other problem-solving operations‚Äù Or ‚ÄùA procedure for solving a mathematical problem in a finite number of steps that frequently involves recursive operations‚Äù.",
              "source": "@site/docs/algorithms/01-intro.md",
              "sourceDirName": "algorithms",
              "slug": "/algorithms/intro",
              "permalink": "/algorithms/intro",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/algorithms/01-intro.md",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "sidebar_position": 1,
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "next": {
                "title": "Kadane's Algorithm",
                "permalink": "/algorithms/kadanes-algorithm/"
              }
            },
            {
              "unversionedId": "algorithms/kadanes-algorithm/flip-bits",
              "id": "algorithms/kadanes-algorithm/flip-bits",
              "title": "Flip Bits",
              "description": "Problem Statement",
              "source": "@site/docs/algorithms/02-kadanes-algorithm/flip-bits.mdx",
              "sourceDirName": "algorithms/02-kadanes-algorithm",
              "slug": "/algorithms/kadanes-algorithm/flip-bits",
              "permalink": "/algorithms/kadanes-algorithm/flip-bits",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/algorithms/02-kadanes-algorithm/flip-bits.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Flip Bits",
                "displayed_sidebar": "algorithms",
                "keywords": [
                  "Kadane's Algorithms",
                  "Flip Bits",
                  "Dynamic Programming",
                  "Subarray",
                  "Maximize number of 1s by flipping a subarray"
                ]
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Kadane's Algorithm",
                "permalink": "/algorithms/kadanes-algorithm/"
              },
              "next": {
                "title": "Maximum Subarray Sum",
                "permalink": "/algorithms/kadanes-algorithm/maximum-subarray-sum"
              }
            },
            {
              "unversionedId": "algorithms/kadanes-algorithm/index",
              "id": "algorithms/kadanes-algorithm/index",
              "title": "Kadane's Algorithm",
              "description": "Kadane's algorithm is an algorithm for finding the maximum sum of a",
              "source": "@site/docs/algorithms/02-kadanes-algorithm/index.mdx",
              "sourceDirName": "algorithms/02-kadanes-algorithm",
              "slug": "/algorithms/kadanes-algorithm/",
              "permalink": "/algorithms/kadanes-algorithm/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/algorithms/02-kadanes-algorithm/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Introduction to Algorithms",
                "permalink": "/algorithms/intro"
              },
              "next": {
                "title": "Flip Bits",
                "permalink": "/algorithms/kadanes-algorithm/flip-bits"
              }
            },
            {
              "unversionedId": "algorithms/kadanes-algorithm/maximum-subarray-sum",
              "id": "algorithms/kadanes-algorithm/maximum-subarray-sum",
              "title": "Maximum Subarray Sum",
              "description": "Solution",
              "source": "@site/docs/algorithms/02-kadanes-algorithm/maximum-subarray-sum.mdx",
              "sourceDirName": "algorithms/02-kadanes-algorithm",
              "slug": "/algorithms/kadanes-algorithm/maximum-subarray-sum",
              "permalink": "/algorithms/kadanes-algorithm/maximum-subarray-sum",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/algorithms/02-kadanes-algorithm/maximum-subarray-sum.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Maximum Subarray Sum",
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Flip Bits",
                "permalink": "/algorithms/kadanes-algorithm/flip-bits"
              },
              "next": {
                "title": "Monotonic Stack",
                "permalink": "/algorithms/monotonic-stack/"
              }
            },
            {
              "unversionedId": "algorithms/monotonic-stack/index",
              "id": "algorithms/monotonic-stack/index",
              "title": "Monotonic Stack",
              "description": "Problems",
              "source": "@site/docs/algorithms/03-monotonic-stack/index.mdx",
              "sourceDirName": "algorithms/03-monotonic-stack",
              "slug": "/algorithms/monotonic-stack/",
              "permalink": "/algorithms/monotonic-stack/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/algorithms/03-monotonic-stack/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "displayed_sidebar": "algorithms"
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Maximum Subarray Sum",
                "permalink": "/algorithms/kadanes-algorithm/maximum-subarray-sum"
              },
              "next": {
                "title": "String Algorithms",
                "permalink": "/algorithms/string-algorithms"
              }
            },
            {
              "unversionedId": "algorithms/string-algorithms",
              "id": "algorithms/string-algorithms",
              "title": "String Algorithms",
              "description": "Here is a list of some common string algorithms:",
              "source": "@site/docs/algorithms/04-string-algorithms.mdx",
              "sourceDirName": "algorithms",
              "slug": "/algorithms/string-algorithms",
              "permalink": "/algorithms/string-algorithms",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/algorithms/04-string-algorithms.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 4,
              "frontMatter": {
                "title": "String Algorithms",
                "displayed_sidebar": "algorithms",
                "keywords": [
                  "Algorithms on String",
                  "String"
                ]
              },
              "sidebar": "algorithms",
              "previous": {
                "title": "Monotonic Stack",
                "permalink": "/algorithms/monotonic-stack/"
              }
            },
            {
              "unversionedId": "data-structures/graph/bipartite-graph/index",
              "id": "data-structures/graph/bipartite-graph/index",
              "title": "Bipartite Graph",
              "description": "Solved Examples",
              "source": "@site/docs/data-structures/graph/bipartite-graph/index.mdx",
              "sourceDirName": "data-structures/graph/bipartite-graph",
              "slug": "/data-structures/graph/bipartite-graph/",
              "permalink": "/data-structures/graph/bipartite-graph/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/graph/bipartite-graph/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Bipartite Graph",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Bipartite",
                  "Graph"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Connected Components",
                "permalink": "/data-structures/graph/connected-components"
              },
              "next": {
                "title": "Possible Bipartition",
                "permalink": "/data-structures/graph/bipartite-graph/possible_bipartition"
              }
            },
            {
              "unversionedId": "data-structures/graph/bipartite-graph/possible_bipartition",
              "id": "data-structures/graph/bipartite-graph/possible_bipartition",
              "title": "Possible Bipartition",
              "description": "Problem Statement",
              "source": "@site/docs/data-structures/graph/bipartite-graph/01_possible_bipartition.mdx",
              "sourceDirName": "data-structures/graph/bipartite-graph",
              "slug": "/data-structures/graph/bipartite-graph/possible_bipartition",
              "permalink": "/data-structures/graph/bipartite-graph/possible_bipartition",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/graph/bipartite-graph/01_possible_bipartition.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "title": "Possible Bipartition",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Possible Bipartition",
                  "Bipartite",
                  "Graph",
                  "DSA"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Bipartite Graph",
                "permalink": "/data-structures/graph/bipartite-graph/"
              },
              "next": {
                "title": "Tree",
                "permalink": "/data-structures/tree/"
              }
            },
            {
              "unversionedId": "data-structures/graph/connected-components",
              "id": "data-structures/graph/connected-components",
              "title": "Connected Components",
              "description": "Practice Problems",
              "source": "@site/docs/data-structures/graph/01_connected-components.mdx",
              "sourceDirName": "data-structures/graph",
              "slug": "/data-structures/graph/connected-components",
              "permalink": "/data-structures/graph/connected-components",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/graph/01_connected-components.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "title": "Connected Components",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Connected Components",
                  "Graph"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Graph",
                "permalink": "/data-structures/graph/"
              },
              "next": {
                "title": "Bipartite Graph",
                "permalink": "/data-structures/graph/bipartite-graph/"
              }
            },
            {
              "unversionedId": "data-structures/graph/index",
              "id": "data-structures/graph/index",
              "title": "Graph",
              "description": "Here are some important topics related to graphs that are commonly covered in technical interviews:",
              "source": "@site/docs/data-structures/graph/index.mdx",
              "sourceDirName": "data-structures/graph",
              "slug": "/data-structures/graph/",
              "permalink": "/data-structures/graph/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/graph/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Graph",
                "displayed_sidebar": "dataStructures"
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Introduction to Data Structures",
                "permalink": "/data-structures/intro"
              },
              "next": {
                "title": "Connected Components",
                "permalink": "/data-structures/graph/connected-components"
              }
            },
            {
              "unversionedId": "data-structures/intro",
              "id": "data-structures/intro",
              "title": "Introduction to Data Structures",
              "description": "A data structure is a storage that is used to store and organize data. It is a way of arranging data on a computer so that it can be accessed and updated efficiently.",
              "source": "@site/docs/data-structures/01_intro.mdx",
              "sourceDirName": "data-structures",
              "slug": "/data-structures/intro",
              "permalink": "/data-structures/intro",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/01_intro.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "sidebar_position": 1,
                "displayed_sidebar": "dataStructures"
              },
              "sidebar": "dataStructures",
              "next": {
                "title": "Graph",
                "permalink": "/data-structures/graph/"
              }
            },
            {
              "unversionedId": "data-structures/tree/dfs",
              "id": "data-structures/tree/dfs",
              "title": "DFS traversal in Tree",
              "description": "Algorithm",
              "source": "@site/docs/data-structures/tree/01-dfs.mdx",
              "sourceDirName": "data-structures/tree",
              "slug": "/data-structures/tree/dfs",
              "permalink": "/data-structures/tree/dfs",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/tree/01-dfs.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 1,
              "frontMatter": {
                "title": "DFS traversal in Tree",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "DFS",
                  "Depth first search",
                  "Tree",
                  "Data Structure",
                  "Algorithm"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Tree",
                "permalink": "/data-structures/tree/"
              },
              "next": {
                "title": "Root Shifting",
                "permalink": "/data-structures/tree/root-shifting"
              }
            },
            {
              "unversionedId": "data-structures/tree/index",
              "id": "data-structures/tree/index",
              "title": "Tree",
              "description": "Here are some important topics related to trees that are commonly covered in technical interviews:",
              "source": "@site/docs/data-structures/tree/index.mdx",
              "sourceDirName": "data-structures/tree",
              "slug": "/data-structures/tree/",
              "permalink": "/data-structures/tree/",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/tree/index.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "frontMatter": {
                "title": "Tree",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Tree",
                  "DSA",
                  "Algorithms"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "Possible Bipartition",
                "permalink": "/data-structures/graph/bipartite-graph/possible_bipartition"
              },
              "next": {
                "title": "DFS traversal in Tree",
                "permalink": "/data-structures/tree/dfs"
              }
            },
            {
              "unversionedId": "data-structures/tree/root-shifting",
              "id": "data-structures/tree/root-shifting",
              "title": "Root Shifting",
              "description": "Practice Problems",
              "source": "@site/docs/data-structures/tree/99-root-shifting.mdx",
              "sourceDirName": "data-structures/tree",
              "slug": "/data-structures/tree/root-shifting",
              "permalink": "/data-structures/tree/root-shifting",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/data-structures/tree/99-root-shifting.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 99,
              "frontMatter": {
                "title": "Root Shifting",
                "displayed_sidebar": "dataStructures",
                "keywords": [
                  "Root Shifting",
                  "Tree",
                  "Data Structure",
                  "Algorithm"
                ]
              },
              "sidebar": "dataStructures",
              "previous": {
                "title": "DFS traversal in Tree",
                "permalink": "/data-structures/tree/dfs"
              }
            },
            {
              "unversionedId": "standard-problems/Blind75",
              "id": "standard-problems/Blind75",
              "title": "Blind75",
              "description": "Array",
              "source": "@site/docs/standard-problems/02-Blind75.md",
              "sourceDirName": "standard-problems",
              "slug": "/standard-problems/Blind75",
              "permalink": "/standard-problems/Blind75",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/standard-problems/02-Blind75.md",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 2,
              "frontMatter": {},
              "sidebar": "sidebar",
              "previous": {
                "title": "Standard Problems",
                "permalink": "/category/standard-problems"
              },
              "next": {
                "title": "intro",
                "permalink": "/standard-problems/intro"
              }
            },
            {
              "unversionedId": "standard-problems/CSES ProblemSet",
              "id": "standard-problems/CSES ProblemSet",
              "title": "CSES Problem Set",
              "description": "This document contains a numbered list of all the problems from the",
              "source": "@site/docs/standard-problems/03-CSES ProblemSet.md",
              "sourceDirName": "standard-problems",
              "slug": "/standard-problems/CSES ProblemSet",
              "permalink": "/standard-problems/CSES ProblemSet",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/standard-problems/03-CSES ProblemSet.md",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 3,
              "frontMatter": {},
              "sidebar": "sidebar",
              "previous": {
                "title": "intro",
                "permalink": "/standard-problems/intro"
              }
            },
            {
              "unversionedId": "standard-problems/intro",
              "id": "standard-problems/intro",
              "title": "intro",
              "description": "SDE Sheet contains very handily crafted and picked top coding interview questions from different topics of Data Structures & Algorithms. These questions are one of the most asked coding interview questions in coding interviews of companies like Amazon, Microsoft, Media.net, Flipkart, etc, and cover almost all of the concepts related to Data Structure & Algorithms",
              "source": "@site/docs/standard-problems/01_intro.mdx",
              "sourceDirName": "standard-problems",
              "slug": "/standard-problems/intro",
              "permalink": "/standard-problems/intro",
              "draft": false,
              "editUrl": "https://github.com/ashuthe1/blog/tree/main/docs/standard-problems/01_intro.mdx",
              "tags": [],
              "version": "current",
              "lastUpdatedBy": "Author",
              "lastUpdatedAt": 1539502055,
              "formattedLastUpdatedAt": "Oct 14, 2018",
              "sidebarPosition": 3,
              "frontMatter": {
                "sidebar_position": 3,
                "displayed_sidebar": "StandardProblems"
              },
              "sidebar": "StandardProblems",
              "previous": {
                "title": "Blind75",
                "permalink": "/standard-problems/Blind75"
              },
              "next": {
                "title": "CSES Problem Set",
                "permalink": "/standard-problems/CSES ProblemSet"
              }
            }
          ],
          "drafts": [],
          "sidebars": {
            "dataStructures": [
              {
                "type": "doc",
                "id": "data-structures/intro"
              },
              {
                "type": "category",
                "label": "Graph",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "data-structures/graph/connected-components"
                  },
                  {
                    "type": "category",
                    "label": "Bipartite Graph",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "data-structures/graph/bipartite-graph/possible_bipartition"
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "data-structures/graph/bipartite-graph/index"
                    }
                  }
                ],
                "link": {
                  "type": "doc",
                  "id": "data-structures/graph/index"
                }
              },
              {
                "type": "category",
                "label": "Tree",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "data-structures/tree/dfs"
                  },
                  {
                    "type": "doc",
                    "id": "data-structures/tree/root-shifting"
                  }
                ],
                "link": {
                  "type": "doc",
                  "id": "data-structures/tree/index"
                }
              }
            ],
            "algorithms": [
              {
                "type": "doc",
                "id": "algorithms/intro"
              },
              {
                "type": "category",
                "label": "Kadane's Algorithm",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "algorithms/kadanes-algorithm/flip-bits"
                  },
                  {
                    "type": "doc",
                    "id": "algorithms/kadanes-algorithm/maximum-subarray-sum"
                  }
                ],
                "link": {
                  "type": "doc",
                  "id": "algorithms/kadanes-algorithm/index"
                }
              },
              {
                "type": "doc",
                "label": "Monotonic Stack",
                "id": "algorithms/monotonic-stack/index"
              },
              {
                "type": "doc",
                "id": "algorithms/string-algorithms"
              }
            ],
            "StandardProblems": [
              {
                "type": "doc",
                "id": "standard-problems/Blind75"
              },
              {
                "type": "doc",
                "id": "standard-problems/intro"
              },
              {
                "type": "doc",
                "id": "standard-problems/CSES ProblemSet"
              }
            ],
            "sidebar": [
              {
                "type": "category",
                "label": "Data Structures",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "data-structures/intro"
                  },
                  {
                    "type": "category",
                    "label": "Graph",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "data-structures/graph/connected-components"
                      },
                      {
                        "type": "category",
                        "label": "Bipartite Graph",
                        "collapsible": true,
                        "collapsed": true,
                        "items": [
                          {
                            "type": "doc",
                            "id": "data-structures/graph/bipartite-graph/possible_bipartition"
                          }
                        ],
                        "link": {
                          "type": "doc",
                          "id": "data-structures/graph/bipartite-graph/index"
                        }
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "data-structures/graph/index"
                    }
                  },
                  {
                    "type": "category",
                    "label": "Tree",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "data-structures/tree/dfs"
                      },
                      {
                        "type": "doc",
                        "id": "data-structures/tree/root-shifting"
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "data-structures/tree/index"
                    }
                  }
                ],
                "link": {
                  "type": "generated-index",
                  "description": "5 minutes to learn the most important Data Structures.",
                  "slug": "/category/data-structures",
                  "permalink": "/category/data-structures"
                }
              },
              {
                "type": "category",
                "label": "Algorithms",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "algorithms/intro"
                  },
                  {
                    "type": "category",
                    "label": "Kadane's Algorithm",
                    "collapsible": true,
                    "collapsed": true,
                    "items": [
                      {
                        "type": "doc",
                        "id": "algorithms/kadanes-algorithm/flip-bits"
                      },
                      {
                        "type": "doc",
                        "id": "algorithms/kadanes-algorithm/maximum-subarray-sum"
                      }
                    ],
                    "link": {
                      "type": "doc",
                      "id": "algorithms/kadanes-algorithm/index"
                    }
                  },
                  {
                    "type": "doc",
                    "label": "Monotonic Stack",
                    "id": "algorithms/monotonic-stack/index"
                  },
                  {
                    "type": "doc",
                    "id": "algorithms/string-algorithms"
                  }
                ],
                "link": {
                  "type": "generated-index",
                  "description": "5 minutes to learn the most important Algorithms.",
                  "slug": "/category/algorithms",
                  "permalink": "/category/algorithms"
                }
              },
              {
                "type": "category",
                "label": "Standard Problems",
                "collapsible": true,
                "collapsed": true,
                "items": [
                  {
                    "type": "doc",
                    "id": "standard-problems/Blind75"
                  },
                  {
                    "type": "doc",
                    "id": "standard-problems/intro"
                  },
                  {
                    "type": "doc",
                    "id": "standard-problems/CSES ProblemSet"
                  }
                ],
                "link": {
                  "type": "generated-index",
                  "description": "Important patternt to master interviews!",
                  "slug": "/category/standard-problems",
                  "permalink": "/category/standard-problems"
                }
              }
            ]
          }
        }
      ]
    }
  },
  "docusaurus-plugin-content-blog": {
    "default": {
      "blogSidebarTitle": "Recent posts",
      "blogPosts": [
        {
          "id": "cp-roadmap-for-beginners-and-people-below-specialist",
          "metadata": {
            "permalink": "/cp-roadmap-for-beginners-and-people-below-specialist",
            "editUrl": "https://github.com/ashuthe1/blog/tree/main/blog/2023-04-17-cp-roadmap-for-beginners-and-people-below-specialist.mdx",
            "source": "@site/blog/2023-04-17-cp-roadmap-for-beginners-and-people-below-specialist.mdx",
            "title": "Cp Roadmap for beginners and People below Specialist",
            "description": "I come across folks who seek guidance for progressing in cp and most of them are pupils / newbies,",
            "date": "2023-04-17T00:00:00.000Z",
            "formattedDate": "April 17, 2023",
            "tags": [
              {
                "label": "CP",
                "permalink": "/tags/cp"
              },
              {
                "label": "Roadmap",
                "permalink": "/tags/roadmap"
              },
              {
                "label": "DSA",
                "permalink": "/tags/dsa"
              },
              {
                "label": "CodeChef",
                "permalink": "/tags/code-chef"
              },
              {
                "label": "CodeForces",
                "permalink": "/tags/code-forces"
              }
            ],
            "readingTime": 6.075,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Ashutosh Gautam",
                "title": "4 üåü CodeChef </> üî∏Specialist @CodeForces üî∏Problem Setter at iMochaWorks",
                "url": "https://github.com/ashuthe1",
                "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
                "key": "ashuthe1"
              }
            ],
            "frontMatter": {
              "slug": "cp-roadmap-for-beginners-and-people-below-specialist",
              "title": "Cp Roadmap for beginners and People below Specialist",
              "authors": [
                "ashuthe1"
              ],
              "tags": [
                "CP",
                "Roadmap",
                "DSA",
                "CodeChef",
                "CodeForces"
              ]
            },
            "nextItem": {
              "title": "232. Implement Queue using Stacks",
              "permalink": "/leetcode/implement-queue-using-stacks"
            }
          },
          "content": "I come across folks who seek guidance for progressing in cp and most of them are pupils / newbies, \nbecause when you reach a Specialist you yourself know what has to be done to progress further . So for those here is some advice. \n\nSo let's start with Beginners or People with rating 800 - 1200. <br/>\nIf your graph looks something like below profile , you are at level 1 , your first goal should be reaching <br/> specialist -> 1400 rating . \n\n<!--truncate-->\n\n![image](https://user-images.githubusercontent.com/86846633/232587990-4b17bdf4-8eef-40a0-9fe2-88772605d39f.png)\n\nTopics needed to attain level 2 (>=1400) in order of their importance.\n\n0) stl in c++ , Collections in Java or equivalent . <br/>\n1) Basic maths , basic logic  <br/>\n2) Searching - Sorting , greedy , two pointers ,sliding window  <br/>\n3) Implementation , stl based  <br/>\n4) Binary search ( very important and a saviour) <br/> \n5) Number theory  <br/>\n6) Basic bit manipulation and basic combinatorics. (very basic)\n\n## Practice strategy \nTwo types of practice are needed :-  <br/>\n1) to build critical thinking / problem solving / application of concepts known.  <br/>\n2) to learn new concepts, tricks and standard problems.  <br/>\n\nFor the first kind of practice you have to solve 40 each in the rating range 800-1400. You can skip a level if you are way too comfortable with it , but don't do more than 50 of any level and waste your time , most beginners do 100-150 800‚Äôs which are completely wasted as in the above profile, the person has done 100 800‚Äôs .\nSo do 40 each 800->900->1000->1100->1200->1300->1400.\nNow at this point you would be able to do A,B and C sometimes.\nNow do 10 more of each if you want .\nNow if you do this you will reach near 1400 . \n\n## Learning strategy\nYou can learn on the fly by just reading editorials and solutions , but it would be more helpful if you spare some time for learning new things.\nFor the topics listed above just search on youtube or google about what are those algos now for doing some standard problems. Resource is Cses Problemset - those are educative and standard problems.\nCompetitive programming handbook - very soothing book .\nLuv‚Äôs youtube channel has a competitive programming playlist\nWhich is also a nice resource to learn things from beginners' pov . \nYou can actually follow any thing you wish just search on google / yt try reading/ watching if you don't get ,-> switch , after two three tries , you will find something which works for you .\n\nBottomline - practice consistently and 40/50 of each rating till 1400 and learn some standard algos , tricks .\n\n\n\n\n\n\n\n\nFrom level 2 (1400) to level 3 (1500-Expert) .\n\nTopics : \nStrong implementation  , speed , accuracy and brute force.\nBinary Search(very important ),\nNumber Theory , \nBit manipulation and Combinatorics ( basic - intermediate)\nTrees / graph -> basic ( questions <=1600/1700 rated)\nDynamic Programming ( 1600-1700 ) , standard problems.\n\nPractice strategy\n1)  For first kind of practice\nnow you need to practise 40 each in 1500 - 1600\nThen 10 each of both .\nNow if you have 50 of each till 1600 begin with 1700 , 1800 \nStrategy remains the same 40 each then after 10 more for each .\n2)  For second kind - Learning strategy \nLearn binary search on answer and everything related to binary search \nDo some good problems on bit manipulation and combinatorics as you encounter them.\nStart learning dp and trees side by side or one after from youtube or wherever you wish ( I started trees from codencode and dp from Aditya Verma) .\nCan refer Cses for standard problems. \n\nBottomline:- If you do this you will reach or have potential to reach expert(>1600) .\n\n\n\n3) For people being specialist and want to reach Expert \n\nYou have to do 40-50 each till 1800 .\n When you complete 1800 then you might reach Expert soon , \nI take it like this - you should solve <=x+200 in problems set to reach a rating x in contests .\nTopics to be covered - Trees ,Graphs, Dp , Segment trees/Range query data structures.\nLearn various useful graphs algos like mst, toposort etc , you should be doing plenty of problems on dp , you should learn segment trees and solve questions on it.\nSo all in all you have to master these topics and come to intermediate or above intermediate level .\nResources- Cp algorithms , Competitive programming handbook,\nAnd tbh any good tutorial , web or video based which you like ,     doesn't matter much .\n\n\n\n## Necessary points to keep in mind  :\n\n1) Participate in every contest , don't care about ratings till you reach an expert. Learnings in one contest = learnings for one week in practice .\n\n2) Always upsolve the problem you couldn't do (<=C in cf div2 rounds) and watch others' solutions who are better rated / your idols -how , why they did that problem in that way ,(lol just stalk their solutions ).\n\n3) In a month if you do 100 problems it's great , you should tap on your shoulder. That costs like 3 problems a day, very much doable if consistent. \n\n4) If you feel uncomfortable with the new rating don‚Äôt back out, it's fine . \nWhen I moved to a new rating I did the first 20 mostly by reading editorials, \ntaking hints etc . You can do the same but just understand the intuition behind it.\nAlso you will come across some problem where you won‚Äôt understand anything even after reading \neditorial and trying your way out . In such a situation , leave that problem for the future or ignore it for  sometime but don‚Äôt waste your day on that one problem .\n5) Make a habit of learning some algo or doing some standard tasks like cses too.\n\n6) Be consistent , be confident , and perform in contests and if couldnt analyse your mistakes.\n\n7) One more golden advice in each question is to try to extract some conclusions/ some facts / some standard knowledge which you can use in other problems too. For example median is the point which has the least sum of difference from n points . Anything, the bottomline is that from each problem you should try to extract some takeaways which you can use in other problems too. \n\n8) Uplift yourself no matter what , even if you are on bottom of rank list just know that , you are still the best , don‚Äôt be too harsh on yourself because-there is whole world against  you and at the end of the day It has to be you on your side ,  only you are there to pamper yourself so be easy on yourself , just learn from your mistakes and remember everyday is a new day .\n\n9) Save the algorithms or implementation in files or snippets so that you can revisit , for example I have many files named as , graph_algorithms, dp , utility functions , string algos, range based data structures etc. So when I forget something I revisit that also I can use codes in contests.\n\n## Who am I ? \nhttps://www.codechef.com/users/ashuthe1x ."
        },
        {
          "id": "leetcode/implement-queue-using-stacks",
          "metadata": {
            "permalink": "/leetcode/implement-queue-using-stacks",
            "editUrl": "https://github.com/ashuthe1/blog/tree/main/blog/leetcode-daily/2022-12-16-implement-queue-using-stacks.mdx",
            "source": "@site/blog/leetcode-daily/2022-12-16-implement-queue-using-stacks.mdx",
            "title": "232. Implement Queue using Stacks",
            "description": "Problem Statement",
            "date": "2022-12-16T00:00:00.000Z",
            "formattedDate": "December 16, 2022",
            "tags": [
              {
                "label": "LeetCode",
                "permalink": "/tags/leet-code"
              },
              {
                "label": "Leetcode Daily",
                "permalink": "/tags/leetcode-daily"
              },
              {
                "label": "DSA",
                "permalink": "/tags/dsa"
              },
              {
                "label": "Stack",
                "permalink": "/tags/stack"
              },
              {
                "label": "Queue",
                "permalink": "/tags/queue"
              }
            ],
            "readingTime": 3.265,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Ashutosh Gautam",
                "title": "4 üåü CodeChef </> üî∏Specialist @CodeForces üî∏Problem Setter at iMochaWorks",
                "url": "https://github.com/ashuthe1",
                "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
                "key": "ashuthe1"
              }
            ],
            "frontMatter": {
              "slug": "leetcode/implement-queue-using-stacks",
              "title": "232. Implement Queue using Stacks",
              "authors": "ashuthe1",
              "tags": [
                "LeetCode",
                "Leetcode Daily",
                "DSA",
                "Stack",
                "Queue"
              ]
            },
            "prevItem": {
              "title": "Cp Roadmap for beginners and People below Specialist",
              "permalink": "/cp-roadmap-for-beginners-and-people-below-specialist"
            },
            "nextItem": {
              "title": "1143. Longest Common Subsequence, LeetCode",
              "permalink": "/leetcode/longest-common-subsequence"
            }
          },
          "content": "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Problem Statement\n\nImplement a first in first out (FIFO) queue using only two stacks.\nThe implemented queue should support all the functions of a normal\nqueue (`push`, `peek`, `pop`, and `empty`).\n\nImplement the `MyQueue` class:\n\n`void push(int x)` Pushes element x to the back of the queue.\n`int pop()` Removes the element from the front of the queue and returns it.\n`int peek()` Returns the element at the front of the queue.\n`boolean empty()` Returns `true` if the queue is empty, `false` otherwise.\n\n<!--truncate-->\n\n**Notes:**\n\n- You must use only standard operations of a stack, which means only `push to top`,\n`peek/pop from top`, `size`, and `is empty` operations are valid.\n- Depending on your language, the stack may not be supported natively. You may\nsimulate a stack using a list or deque (double-ended queue) as long as you use\nonly a stack's standard operations.\n\nExample 1:\n```text\nInput:\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput:\n[null, null, null, 1, 1, false]\n\nExplanation:\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n```\n\nConstraints:\n- `1 <= x <= 9`\n- At most `100` calls will be made to `push`, `pop`, `peek`, and `empty`.\n- All the calls to `pop` and `peek` are valid.\n\n## Follow Up\nCan you implement the queue such that each operation is [amortized](https://en.wikipedia.org/wiki/Amortized_analysis)\n`O(1)` time complexity? In other words, performing `n` operations will take\noverall `O(n)` time even if one of those operations may take longer.\n\n## Explanation\n\nProperties of Queue:\n```mermaid\nflowchart LR;\n\nqueue[Queue Data Structure];\npush((Push));\npeek((Peek));\npop((Pop));\nfront[Front];\nback[Back];\n\npop --- front --- queue --- back --- push;\npeek --- front;\n```\n\nProperties of Stack:\n```mermaid\nflowchart LR;\n\nstack[Stack Data Structure];\npush((Push));\npeek((Peek));\npop((Pop));\nfront[Front];\nback[Back];\n\nfront --- stack --- back --- push;\nback --- pop;\nback --- peek;\n```\n\nInorder to create queue using stack, we can use combination of 2 stacks (say `stack1`, `stack2`);\n\n### Queue: Push\n- push new element to `stack1`\n- oldest element pushed will be in the bottom of stack\n- newest element pushed will be on the top of stack\n\n### Queue: Peek\n- IF `stack2` is empty then oldest element will be at the\nbottom of `stack1` else oldest element will be on top of `stack2`\n```text\nIF stack2 is empty\n    WHILE stack1 is not empty\n        pop element from stack1\n        push element into stack2\n```\n- Now, oldest element will always be on the top of `stack2`\n\n### Queue: Pop\n- same as finding the peek, then just pop peek element from `stack2`.\n- after, pop operation on `stack2`, 2nd oldest will again come on top of `stack2`.\n\n## Solution\n\n<Tabs>\n\n<TabItem value=\"cpp\" label=\"C++ Two User Stack\">\n\n```cpp title='C++ Solution using Two User Defined Stack'\nclass MyQueue {\nprivate:\n    stack<int> s1, s2;\npublic:\n    MyQueue() {\n\n    }\n    \n    void push(int x) {\n        s1.push(x);\n    }\n    \n    int pop() {\n        if(s2.empty()) {\n            while(!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        int ans = s2.top();\n        s2.pop();\n        return ans;\n    }\n    \n    int peek() {\n        if(s2.empty()) {\n            while(!s1.empty()) {\n                s2.push(s1.top());\n                s1.pop();\n            }\n        }\n        return s2.top();\n    }\n    \n    bool empty() {\n        return s1.size() + s2.size() == 0;\n    }\n};\n\n\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue* obj = new MyQueue();\n * obj->push(x);\n * int param_2 = obj->pop();\n * int param_3 = obj->peek();\n * bool param_4 = obj->empty();\n */\n```\nTime Complexity:\n- Push: O(1)\n- Pop: O(N), amortized: O(1)\n- Peek: O(N), amortized: O(1)\n\nSpace Complexity: O(N)\n\n</TabItem>\n\n</Tabs>\n\n\n## Related Problems\n- [Implement Stack using Queues - GeeksforGeeks](https://www.geeksforgeeks.org/implement-stack-using-queue/)\n- [225. Implement Stack using Queues - LeetCode](https://leetcode.com/problems/implement-stack-using-queues/)\n\n## References\n- [Queue using Stacks - GeeksforGeeks](https://www.geeksforgeeks.org/queue-using-stacks/)\n\n## Links\n- [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\n- [LeetCode Discussion Post - Suraj Jha](https://leetcode.com/problems/implement-queue-using-stacks/solutions/2918885/c-solution-using-two-user-defined-stack-time-o-1-space-o-n/)"
        },
        {
          "id": "leetcode/longest-common-subsequence",
          "metadata": {
            "permalink": "/leetcode/longest-common-subsequence",
            "editUrl": "https://github.com/ashuthe1/blog/tree/main/blog/leetcode-daily/2022-12-15-longest-common-subsequence.mdx",
            "source": "@site/blog/leetcode-daily/2022-12-15-longest-common-subsequence.mdx",
            "title": "1143. Longest Common Subsequence, LeetCode",
            "description": "Problem Statement",
            "date": "2022-12-15T00:00:00.000Z",
            "formattedDate": "December 15, 2022",
            "tags": [
              {
                "label": "LeetCode",
                "permalink": "/tags/leet-code"
              },
              {
                "label": "Leetcode Daily",
                "permalink": "/tags/leetcode-daily"
              },
              {
                "label": "DSA",
                "permalink": "/tags/dsa"
              },
              {
                "label": "Dynamic Programming",
                "permalink": "/tags/dynamic-programming"
              },
              {
                "label": "String",
                "permalink": "/tags/string"
              }
            ],
            "readingTime": 3.105,
            "hasTruncateMarker": true,
            "authors": [
              {
                "name": "Ashutosh Gautam",
                "title": "4 üåü CodeChef </> üî∏Specialist @CodeForces üî∏Problem Setter at iMochaWorks",
                "url": "https://github.com/ashuthe1",
                "imageURL": "https://avatars.githubusercontent.com/u/86846633?v=4",
                "key": "ashuthe1"
              }
            ],
            "frontMatter": {
              "slug": "leetcode/longest-common-subsequence",
              "title": "1143. Longest Common Subsequence, LeetCode",
              "authors": "ashuthe1",
              "tags": [
                "LeetCode",
                "Leetcode Daily",
                "DSA",
                "Dynamic Programming",
                "String"
              ]
            },
            "prevItem": {
              "title": "232. Implement Queue using Stacks",
              "permalink": "/leetcode/implement-queue-using-stacks"
            }
          },
          "content": "import Tabs from '@theme/Tabs';\nimport TabItem from '@theme/TabItem';\n\n## Problem Statement\n\nGiven two strings `text1` and `text2`, return the length of their *longest common subsequence*. If there is no common subsequence, return `0`.\n\nA *subsequence* of a string is a new string generated from the original string with some characters (can be none) deleted without changing the relative order of the remaining characters.\n\n- For example, `\"ace\"` is a subsequence of `\"abcde\"`.\n\nA *common subsequence* of two strings is a subsequence that is common to both strings. \n\n<!--truncate-->\n\nExample 1:\n```text\nInput: text1 = \"abcde\", text2 = \"ace\" \nOutput: 3  \nExplanation: The longest common subsequence is \"ace\" and its length is 3.\n```\n\nExample 2:\n```text\nInput: text1 = \"abc\", text2 = \"abc\"\nOutput: 3\nExplanation: The longest common subsequence is \"abc\" and its length is 3.\n```\n\nExample 3:\n```text\nInput: text1 = \"abc\", text2 = \"def\"\nOutput: 0\nExplanation: There is no such common subsequence, so the result is 0.\n```\n\nConstraints:\n- `1 <= text1.length, text2.length <= 1000`\n- `text1` and `text2` consist of only lowercase English characters.\n\n## Explanation\n\nLet `i1` and `i2` be two pointer pointing at `current` index in string `s1` and `s2` respectively.\n\nlet `dp(i1, i2, s1, s2)` denotes the length of longest common subsequence in string `s1[i1...n1]` and `s2[i2...n2]`.\n\nIf _i1 == n1_, implies s1[i1....n1] is empty.\n\n**Base Case:** longest common subsequence of any string with empty string is 0.\nTherefore is any of _i1 == n1_ or _i2 == n2_ return `0`.\n\nNow, for any `i1` and `i2` there are 2 possibilities.\n\n```mermaid\ngraph TD;\n    root[\"(i1, i2)\"];\n    eq[\"s1[i1] == s2[i2]\"];\n    nq[\"s1[i1] != s2[i2]\"];\n\n    root --> eq -- Pick --> Pick[\"Consider Current Characters in Subsequence\"] --Recursive Call--> next[\"(i1+1, i2+1)\"];\n    eq -- Skip --> Skip[\"Skip Current Characters either from s1 or s2\"];\n\n    root --> nq -- Skip --> Skip;\n\n    Skip --Recursive Call--> next_i1[\"(i1+1, i2)\"];\n    Skip --Recursive Call--> next_i2[\"(i1, i2+1)\"];\n```\n\n## Solution\n\n<Tabs>\n\n<TabItem value=\"cpp1\" label=\"C++ Recursive\">\n\n```cpp title='CPP: Recursive Brute Force Solution [Time Limit Exceeded]'\nclass Solution {\nprivate:\n    int dp(int i1, int i2, string &s1, string &s2) {\n        int n1 = s1.size();\n        int n2 = s2.size();\n\n        // Base Case\n        if(i1 == n1 || i2 == n2) return 0;\n\n        if(s1[i1] == s2[i2]) {\n            return max({\n                dp(i1+1, i2+1, s1, s2) + 1,\n                dp(i1, i2+1, s1, s2),\n                dp(i1+1, i2, s1, s2),\n            });\n        }\n        else {\n            return max({\n                dp(i1, i2+1, s1, s2),\n                dp(i1+1, i2, s1, s2),\n            });\n        }\n    }\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        return dp(0, 0, text1, text2);\n    }\n};\n```\n\nm               |n                  | Time Complexity  | Space Complexity\n----------------|-------------------|------------------|-----------------\nsize of string 1|size of string 2   | O(max(m,n)\\*m\\*n)| O(max(m,n))\n\n</TabItem>\n\n<TabItem value=\"cpp2\" label=\"C++ Recursive DP\">\n\n```cpp title='CPP: Recursive + Memoization [Accepted]'\nclass Solution {\nprivate:\n    int dp(int i1, int i2, string &s1, string &s2, vector<vector<int>> &cache) {\n        int n1 = s1.size();\n        int n2 = s2.size();\n\n        // Base Case\n        if(i1 == n1 || i2 == n2) return 0;\n\n        if(cache[i1][i2] != -1) return cache[i1][i2];\n\n        if(s1[i1] == s2[i2]) {\n            return cache[i1][i2] = max({\n                dp(i1+1, i2+1, s1, s2, cache) + 1,\n                dp(i1, i2+1, s1, s2, cache),\n                dp(i1+1, i2, s1, s2, cache),\n            });\n        }\n        else {\n            return cache[i1][i2] = max({\n                dp(i1, i2+1, s1, s2, cache),\n                dp(i1+1, i2, s1, s2, cache),\n            });\n        }\n    }\npublic:\n    int longestCommonSubsequence(string text1, string text2) {\n        vector<vector<int>> cache(text1.size(), vector<int>(text2.size(), -1));\n        return dp(0, 0, text1, text2, cache);\n    }\n};\n```\n\n\nm               |n                  | Time Complexity  | Space Complexity\n----------------|-------------------|------------------|-----------------\nsize of string 1|size of string 2   | O(m*n)           | O(m*n)\n\n</TabItem>\n\n</Tabs>\n\n\n## Related Problems\n- [Longest Common Substring](https://leetcode.com/discuss/interview-question/1273766/longest-common-substring)\n- [1092. Shortest Common Supersequence](https://leetcode.com/problems/shortest-common-supersequence/)\n- [1062. Longest Repeating Substring](https://leetcode.com/problems/longest-repeating-substring/)\n- [516. Longest Palindromic Subsequence](https://leetcode.com/problems/longest-palindromic-subsequence/)\n\n## References\n- [Longest common subsequence Recursive - YouTube, Aditya Verma](https://youtu.be/4Urd0a0BNng)\n- [Longest common subsequence Tabular - YouTube, Tushar Roy](https://youtu.be/NnD96abizww)"
        }
      ],
      "blogListPaginated": [
        {
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist",
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "metadata": {
            "permalink": "/",
            "page": 1,
            "postsPerPage": 10,
            "totalPages": 1,
            "totalCount": 3,
            "blogDescription": "Blog",
            "blogTitle": "Blog"
          }
        }
      ],
      "blogTags": {
        "/tags/cp": {
          "label": "CP",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/cp",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/cp",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/roadmap": {
          "label": "Roadmap",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/roadmap",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/roadmap",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/dsa": {
          "label": "DSA",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist",
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/dsa",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist",
                "leetcode/implement-queue-using-stacks",
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/dsa",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 3,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/code-chef": {
          "label": "CodeChef",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/code-chef",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/code-chef",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/code-forces": {
          "label": "CodeForces",
          "items": [
            "cp-roadmap-for-beginners-and-people-below-specialist"
          ],
          "permalink": "/tags/code-forces",
          "pages": [
            {
              "items": [
                "cp-roadmap-for-beginners-and-people-below-specialist"
              ],
              "metadata": {
                "permalink": "/tags/code-forces",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/leet-code": {
          "label": "LeetCode",
          "items": [
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/leet-code",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks",
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/leet-code",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 2,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/leetcode-daily": {
          "label": "Leetcode Daily",
          "items": [
            "leetcode/implement-queue-using-stacks",
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/leetcode-daily",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks",
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/leetcode-daily",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 2,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/stack": {
          "label": "Stack",
          "items": [
            "leetcode/implement-queue-using-stacks"
          ],
          "permalink": "/tags/stack",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks"
              ],
              "metadata": {
                "permalink": "/tags/stack",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/queue": {
          "label": "Queue",
          "items": [
            "leetcode/implement-queue-using-stacks"
          ],
          "permalink": "/tags/queue",
          "pages": [
            {
              "items": [
                "leetcode/implement-queue-using-stacks"
              ],
              "metadata": {
                "permalink": "/tags/queue",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/dynamic-programming": {
          "label": "Dynamic Programming",
          "items": [
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/dynamic-programming",
          "pages": [
            {
              "items": [
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/dynamic-programming",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        },
        "/tags/string": {
          "label": "String",
          "items": [
            "leetcode/longest-common-subsequence"
          ],
          "permalink": "/tags/string",
          "pages": [
            {
              "items": [
                "leetcode/longest-common-subsequence"
              ],
              "metadata": {
                "permalink": "/tags/string",
                "page": 1,
                "postsPerPage": 10,
                "totalPages": 1,
                "totalCount": 1,
                "blogDescription": "Blog",
                "blogTitle": "Blog"
              }
            }
          ]
        }
      },
      "blogTagsListPath": "/tags"
    }
  },
  "docusaurus-plugin-content-pages": {
    "default": null
  },
  "docusaurus-plugin-debug": {},
  "docusaurus-theme-classic": {},
  "docusaurus-theme-mermaid": {},
  "docusaurus-bootstrap-plugin": {},
  "docusaurus-mdx-fallback-plugin": {}
}